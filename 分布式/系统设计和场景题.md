---
title: 系统设计和场景
categories:
  - 分布式or设计模式
tags:
  - 系统设计
abbrlink: 46153
date: 2022-07-19 19:54:20
---





# CPU飙升怎么排查



**知乎**

https://zhuanlan.zhihu.com/p/271783423



**博客园（首选）**：https://www.cnblogs.com/dennyzhangdd/p/11585971.html















> 1.执行“top”命令``：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。``
>
> 2.执行“top -Hp 进程号”命令：查看java进程下的所有线程占CPU的情况。
>
> 3.执行“printf "%x\n 10"命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf "%x\n 10-》打印：a，那么在jstack中线程号就是0xa.
>
> 4.执行 “jstack 进程号 | grep 线程ID” 查找某进程下-》线程ID（jstack堆栈信息中的nid）=0xa的线程状态。如果“"VM Thread" os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了
>
> 5.执行“jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。
>
> 6.执行“jmap -dump:format=b,file=filename 进程ID”，导出某进程下内存heap输出到文件中。可以通过eclipse的mat工具查看内存中有哪些对象比较多,飞机票：[Eclipse Memory Analyzer（MAT），内存泄漏插件，安装使用一条龙](https://www.cnblogs.com/dennyzhangdd/p/5647469.html)；





















# 设计一个单点登录系统



https://zhuanlan.zhihu.com/p/66037342















# 性能调优



猎豹小亦Xmind



# 分库分表





按业务 垂直拆分 按数据量 水平拆分





# nginx负载均衡



我理解就IP hashcode对服务数取模 然后权重+粘性策略就行 保证它同一IP来的请求落到同一服务上







# 接口的幂等性



或者说换一种问法：怎样防止用户重复下单







## 前言

`接口幂等性`问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。

不知道你有没有遇到过这些场景：

1. 有时我们在填写某些`form表单`时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。
2. 我们在项目中为了解决`接口超时`问题，通常会引入了`重试机制`。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果（这种情况不可能直接返回失败吧？），于是会对该请求重试几次，这样也会产生重复的数据。
3. mq消费者在读取消息时，有时候会读取到`重复消息`（至于什么原因这里先不说，有兴趣的小伙伴，可以找我私聊），如果处理不好，也会产生重复的数据。

没错，这些都是幂等性问题。

`接口幂等性`是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。

这类问题多发于接口的：

- `insert`操作，这种情况下多次请求，可能会产生重复数据。
- `update`操作，如果只是单纯的更新数据，比如：`update user set status=1 where id=1`，是没有问题的。如果还有计算，比如：`update user set status=status+1 where id=1`，这种情况下多次请求，可能会导致数据错误。









##  insert前先select



## 加悲观锁（※）

数据库表层面

数据库update自带悲观锁

## 加乐观锁（※）



只能用于修改操作

得自己实现

一般在数据库表加个version字段，然后再判断

每次执行修改先查version字段然后判断





##  加唯一索引（※）

数据库表层面



数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。

使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。

- 需要生成全局唯一主键 ID；



这个作为唯一索引的字段一定是全局唯一的



## 建防重表







## 根据状态机



数据库比如订单表加status状态字段



## 加分布式锁（※）

redis分布式锁

这个解决方法与防重Token好像是不一样的

redis 分布式锁机制解决接口幂等性问题。

### 逻辑

1. 用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。
2. 使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。
3. 判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。
4. 如果设置失败，说明是重复请求，则直接返回成功。

> 需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费`redis`的存储空间，需要根据实际业务情况而定。

![img](../../images/%E5%88%86%E5%B8%83%E5%BC%8F/195a5543ce45a636b318b3bfdf1422c1.png)





## 防重token（※）

看这个直接：https://blog.csdn.net/Leon_Jinhai_Sun/article/details/116036312

**注意：与上面的redis分布式锁不一样**











**确认订单的页面先申请一个订单号 然后点击确认订单的时候 一起提交**



调用方在调用接口前先去后端请求一个全局唯一id,并**将该id为key,用户信息为value存进redis**,然后调用方请求的时候带上这个全**局唯一id,后端校验**，如果**redis中存在改key并且value想匹配就删除改key**,并进行业务操作，**如果不存在改key或者value不匹配**，就不进行后续业务操作（重复请求）

























##### 方案描述：

针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。

**逻辑：**

1. 第一次请求获取`token`
2. 第二次请求带着这个`token`，完成业务操作。



##### 适用操作：

- 插入操作
- 更新操作
- 删除操作

##### 使用限制：

- 需要生成全局唯一 Token 串；
- 需要使用第三方组件 Redis 进行数据效验；

##### 主要流程：

![图片](../../images/%E5%88%86%E5%B8%83%E5%BC%8F/640.png)

- ① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。

- ② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。

- ③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。

- ④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。

- ⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。

- ⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。

- ⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。

  

> ###### 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。









## 防止重复提交订单



https://mp.weixin.qq.com/s/yieSqKZbVvpe7R_DhRNVoA



















