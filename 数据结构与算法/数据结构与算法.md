---
title: 数据结构与算法
categories:
  - 数据结构与算法
tags:
  - 数据结构与算法
date: 2022-05-4
cover: 'https://pic2.zhimg.com/v2-f3b7f2277cb8b42523293b5b219bd7dc_r.jpg'
abbrlink: 40445
---



# 前提：

兄弟可能背叛你，女人可能会抛弃你，算法不会，因为不会就是不会。

 下面是**dgw**的数据结构与算法整理



# 数组

## 子序列问题

#### [剑指 Offer II 119. 最长连续序列](https://leetcode-cn.com/problems/WhsWhI/)

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

> 示例 1：
>
> 输入：nums = [100,4,200,1,3,2]
> 输出：4
> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
> 示例 2：
>
> 输入：nums = [0,3,7,2,5,8,4,6,0,1]
> 输出：9

```java
class Solution {
    public int longestConsecutive(int[] nums) {
            int res = 0;
            HashSet<Integer> set = new HashSet<>();
            for(int x : nums) set.add(x);
            for(int x : set) {
                if(!set.contains(x - 1)){
                    int y = x;
                    while(set.contains(y + 1)) y++;
                    res = Math.max(res,y - x + 1);
                }
            }
            return res;
    }
}
```

思路：

把数组所有元素先放进set集合去重，然后遍历枚举set元素，当遍历的元素有前一项时（也就是有当前值减一时）说明前面还有连续的元素，枚举下一个元素，直到枚举的元素没有前一项时，说明之前不可能有元素连续了，那么从这个元素开始加，然后比对set集合里面也没有，不断更新最大值。

时间复杂度是O(N)，因为两个for循环嵌套一般是O(n^2)的，但是一个for嵌套一个while则不一定是O(n^2)，注意看while循环的执行次数，while是总共执行了n次，而不是每次for循环都是n次，因此均摊到总的for循环，相当于每次for循环，while执行了一次。



## 子数组问题

![image-20220414141629607](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220414141629607.png)



```java
class Solution {

  public int maxProduct(int[] nums) {

​    int max = Integer.MIN_VALUE, imax = 1, imin = 1;

​    *for*(int i = 0; i < nums.length; i++) {

​      *if*(nums[i] < 0) {

​        int tmp = imax;

​        imax = imin;

​        imin = tmp;

​      }

​      imax = Math.max(imax * nums[i], nums[i]);

​      imin = Math.min(imin * nums[i], nums[i]);

​      max = Math.max(imax,max);

​    }

  *return* max;

  }

}
```

**解法：**

- 标签：动态规划
- 遍历数组时计算当前最大值，不断更新
- 令imax为当前最大值，则当前最大值为 imax = max(imax * nums[i], nums[i])
- 由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin，imin = min(imin * nums[i], nums[i])
- 当负数出现时则imax与imin进行交换再进行下一步计算
- 时间复杂度：O(n)O(n)









# 二分







## 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。



> ```
> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
> 解释: 9 出现在 nums 中并且下标为 4
> ```



```java
class Solution {

  public int search(int[] nums, int target) {

    int l = 0, r = nums.length - 1;

      (1)
    // 找最左边的target
    //分成了两个区间(0,mid)和(mid + 1,nums.length - 1);
     while(l < r) {
		//int mid = l + (r - l) / 2;这样写是为了防溢出，安全。害，不过我不喜欢。
       int mid = (l + r) / 2;

       if( nums[mid] >= target) r = mid;

       else l =mid + 1;//r > nums[mid]
         
       或者这样写也可以
		if(nums[mid] < target) left = mid + 1;
         else right = mid;
     }

   (2)   
  //找最右边的target
  //分成了两个区间，(0,mid - 1)和(mid,nums.length - 1)
  while(l < r) {

    int mid = (l + r + 1) / 2;

    if(nums[mid] <= target) l = mid;

    else r = mid - 1;

  }

  

    if (r < 0 || nums[r] != target)
    return -1;

    return r;

  }

}
```



### arr中，找大于等于target的最左位置

 

```java
public static int nearestIndex(int[] arr, int value) {
    int L = 0;
    int R = arr.length - 1;
    int index = -1; // 记录最左的对号
    while (L <= R) {
        int mid = L + ((R - L) >> 1);
        if (arr[mid] >= value) {
            index = mid;//此时啊，先记录index右边都是大于value的，那右边的都不要了，包括这个mid,因为左边可能还有大于等于value的，所有r = mid - 1
            R = mid - 1;
        } else {//此时arr[mid] < value的，肯定不记录index,右边有大于等于value的，所有 l = mid + 1;
            L = mid + 1;
        }
    }
    return index;
}
```

### arr中，找大于等于target的最右位置

```java
public static int nearrightIndex(int[] arr, int value) {
    int L = 0;
    int R = arr.length - 1;
    int index = -1; // 记录最左的对号
    while (L <= R) {
        int mid = L + ((R - L) >> 1);
        if (arr[mid] <= value) {
            index = mid;
            L = mid + 1;
        } else {
            R = mid - 1;
        }
    }
    return index;
}
```



### 局部最小值（不一定有序才能二分）



给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，力扣只需返回arr中任意一个局部最小出现的位置

这题是找局部最小值

```java
public static int getLessIndex(int[] arr) {
	if (arr == null || arr.length == 0) {
		return -1; // no exist
	}
	if (arr.length == 1 || arr[0] < arr[1]) {
		return 0;
	}
	if (arr[arr.length - 1] < arr[arr.length - 2]) {
		return arr.length - 1;
	}
	int left = 1;
	int right = arr.length - 2;
	int mid = 0;
	while (left < right) {
		mid = (left + right) / 2;
		if (arr[mid] > arr[mid - 1]) {//mid > arr[mid - 1] 往左边二分找局部最小
			right = mid - 1;
		} else if (arr[mid] > arr[mid + 1]) {//mid值 > arr[mid + 1],往右边二分找局部最小
			left = mid + 1;
		} else {//既不大于左边又不大于右边，那就是小于左右边楼，那就是局部最小喽，返回喽。
			return mid;
		}
	}
	return left;
}
```



在这里第一次说，左神牛逼。

### 局部最大值（不一定有序才能二分）

左神举了局部最小的例子，我在力扣上又找到了局部最大的例子，也就是求峰值这个题。

这是求局部最大值



> **求峰值**
>
> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞ 。
>
> 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
>
> ```
> 输入：nums = [1,2,3,1]
> 输出：2
> 解释：3 是峰值元素，你的函数应该返回其索引 2。
> ```
>
> 。



下面是根据左神那个例子写出的解法

```java
public int findPeakElement(int[] nums) {

    //左神牛逼

    //（1）
    if(nums.length == 1 || nums[0] > nums[1]) return 0;

    if(nums[nums.length - 1] > nums[nums.length - 2]) return nums.length - 1;

    int l = 1, r = nums.length - 2;
    //（2）
    int l = 0, r = nums.length - 1;
    
    上面（1）或者（2）随便选一个，没区别。
    while(l < r) {
        int mid = l + (( r - l) >> 1);
        if(nums[mid] < nums[mid - 1]) {//如果mid指向的值小于左边，右边附近没有局部最大了，反正是只求一个局部值，那就往左边二分
            r = mid - 1;
        } else if(nums[mid] < nums[mid + 1]) {//同理，mid指向的值小于右边，那就往右边二分
            l = mid + 1;
        }
        else{//此时是，mid指向的值·，既不小于左边，又不小于右边，那就是都大于两边喽，那就是局部最大了
            return mid;
        }
    }

    return r;

}
```











## [寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)





![image-20220428224404544](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220428224404544.png)

解释：

用到了什么狗屁抽屉原理

总的来说，while里面是隐形排序，

以mid值为随机值，在nums遍历判断，如果nums小于等于mid的值大于mid那么重复值一定比mid小，也就是right = mid,反之left = mid + 1;

一定注意，在二分的时候是不包含重复值的，根据题意隐式排序



```java
class Solution {
    public int findDuplicate(int[] nums) {
        //隐形排序
        int left = 1;//最小值
        int right = nums.length - 1;//最大值

        while (left < right) {
          int mid = (left + right) / 2;

          int cnt = 0;
          for(int num : nums) {
              if(num <= mid) {
                  cnt++;
              }
          }

          if(cnt > mid) {
              right = mid;
          } else {
              left = mid + 1;
          }

        }

        return left;

    }
}
```





























## 双指针

### 移除元素

- **第一题**

- easy

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2,_]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

easy

```java
class Solution {

  public int removeDuplicates(int[] nums) {

​    int j = 0;

​    for(int i = 0;i < nums.length; i++) {

​      if(nums[i] != nums[j]) {

​        j++;

​        nums[j] = nums[i];

​      }

​    }

​    return j + 1;

  }

}
```

解法:

将数组分为两部分

- 前面一部分为有效数组，是不重复的元素。
- 后面一部分为无效数组，重复的元素。

j指向有效数组的最后一位元素，i遍历数组元素，i指向的元素不断与j指向的元素比较，如果不想同，元素放至 j + 1位置，返回的有效数组的长度是j + 1。

- **第二题**
- easy

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2]
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

**解法一：直接粘贴法**

```java
class Solution {
  public int removeElement(int[] nums, int val) {

​    int j = 0;

​    int m = 0;

​    for(int i = 0; i < nums.length; i++) {

​      if(nums[i] != val){

​        nums[j++] = nums[i];

​      }

​    }

​    return j;

  }

}
```

**解法二：交换移除法**

```java
class Solution {
  public int removeElement(int[] nums, int val) {

​    int j = nums.length - 1;

​    for(int i = 0; i <= j; i++) {

​      if(nums[i] == val){

​       swap(nums,i--,j--);//这个i--很魔性，防止交换回来的元素还是val，i就不能一直往前遍历，做双重交换。

​      }

​    }

​    return j + 1;

  }

  public void swap(int[] nums,int i, int j){

​    int t = nums[i];

​    nums[i] = nums[j];

​    nums[j] = t;

  }

}
```



- 前半段是有效部分，存储的是不等于 `val` 的元素。
- 后半段是无效部分，存储的是等于 `val` 的元素。

i从第一个元素开始，j从最后一个元素开始，i不断往前遍历，遇到val时，与j指向的元素交换，然后i回退一格，防止交换回来的元素也和val相等，那就要再次交换了，最后数组成为两部分，前一部分是不重复的，后一部分全是val，分界点是下标j(包括j),那此时前面有效数组的长度是j+1。





### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

![image-20220308211004723](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220308211004723.png)



```java
class Solution {

  public int maxArea(int[] height) {
    int maxRes = 0;
    int i = 0, j = height.length - 1;
    while(i <= j) {
      int duan = Math.min(height[i],height[j]);
      maxRes = Math.max(maxRes,duan * (j - i));
      if(height[i] < height[j]) i++;
      else j--;
    }
    return maxRes;
  }
}
```

短板缩进，面积可能会变大，但长板缩进不变或者变小。所以不断通过缩进短板来维护面积最大值

### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)



给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：**答案中不可以包含重复的三元组。**

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

本题最重要的是去重，分了三步去重。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();

        Arrays.sort(nums);
        for(int i = 0; i < nums.length; i++) {
            if(nums[i]>0){
                break;
            }
            if(i > 0 && nums[i] == nums[i-1]) continue;//第一步去重，吊，太难想了
            int L = i + 1, R = nums.length - 1;
            while(L < R) {
                int tmp = nums[i] + nums[L] + nums[R];
                if(tmp == 0){
                    res.add(Arrays.asList(nums[i],nums[L],nums[R]));

                    while(L < R && nums[L] == nums[L + 1]) ++L;//第二步去重
                    while(L < R && nums[R] == nums[R - 1]) --R;//第三步去重
                    ++L;
                    --R;
                }else if( tmp > 0){
                    R--;
                }else if(tmp < 0){
                    L++;
                }
            }
        }
        return res;

    }
}
```

定义三个指针，第一个指针在最外层遍历，剩下两个指针遍历第一个指针遍历到的元素的后面的元素，大体可分为外部去重和内部去重，外部去重由第一个指针负责，nums[i]  == nums[i - 1]出现这样的情况第一个指针就要去重，也称外部去重，在while循环里面还要内部去重，两个while循环去重保证，L指针和R指针下次不会遍历到各自上次遍历到的相同的元素。



### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

![image-20220314224048945](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220314224048945.png)





```java
class Solution {

  public void nextPermutation(int[] nums) {

​    //呜呜呜，看不懂，只知道应该这么做，但原理真的看不懂

​    for(int i = nums.length - 1; i > 0; i--) {

​      if(nums[i] > nums[i - 1]) {

​        Arrays.sort(nums, i, nums.length);

​        for(int j = i; j < nums.length; j++) {

​          if(nums[j] > nums[i - 1]) {

​            int temp = nums[j];

​            nums[j] = nums[i - 1];

​            nums[i - 1] = temp;

​            return;

​          }

​        }

​      }

​    }

​    Arrays.sort(nums);

​    return;

  }

}
```

**这题题解就不记录了，因为根本就不会，呜呜呜，看了题解知道这么做可以得到正确答案，但是不知道为什么这样做可以得到答案，复习时直接看题解.**















## 滑动窗口

**无重复字符的最长子串**

![image-20220313223031750](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220313223031750.png)



```java
class Solution {

  public int lengthOfLongestSubstring(String s) {

​    // 滑动窗口

​    int res = 0;

​    HashMap<Character,Integer> map = new HashMap<>();

​    for(int left = 0,right = 0; right < s.length(); right++){

​      if(map.containsKey(s.charAt(right))){

​        left = Math.max(left,map.get(s.charAt(right)));

​      }

​      res = Math.max(res,right - left + 1);

​      map.put(s.charAt(right),right + 1);

​    }  

​    return res;

  }

}
```

利用滑动窗口不断维护一个不重复子串窗口，并且不断维护一个最长长度；

利用map集合，key是字符，value为字符位置加一，加1表示从字符位置后一个才开始不重复

随着right不断相后遍历。会有【left，right】区间内字符相同的情况，此时将字符作为key，获取其value值，并更新left,此时[left,right]区间内不存在重复字符。









## dfs

### 全排列

![image-20220315224609234](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220315224609234.png)







```mysql
class Solution {

   List<List<Integer>> res = new ArrayList<>(); 

   LinkedList<Integer> path = new LinkedList<>(); 

​    boolean[] used;

  public List<List<Integer>> permute(int[] nums) {

​    used = new boolean[nums.length];

​    dfs(nums);

​    return res;

  }

  public void dfs(int[] nums) {

​    

​    if(path.size() == nums.length) {

​      res.add(new ArrayList<>(path));

​      return;

​    }

​    //开始分层递归

  for(int i = 0; i < nums.length; i++) {

​    if(used[i]) {

​      continue;

​    }

​    used[i] = true;

​    path.add(nums[i]);

​    dfs(nums);

​    path.removeLast();

​    used[i] = false;

  }
  }
}
```

经典回溯

![image-20220315224816392](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220315224816392.png)



最主要的是要有个used[]数组记录使用过的元素，这个数组主要作用在每一竖行和每一横行，遍历的时候看是否用到过。

for循环遍历同一层的，递归是遍历下一个层以及下下一层













## 数学

### 旋转图像

![image-20220316230756141](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220316230756141.png)

```java

class Solution {

  public void rotate(int[][] matrix) {

​    //先左上右下翻转

​    for(int i = 0; i < matrix.length; i++) {

​      for(int j = 0; j < i; j++) {

​        int temp = matrix[i][j];

​        matrix[i][j] = matrix[j][i];

​        matrix[j][i] = temp;

​      }

​    }

​    for(int i = 0; i < matrix.length; i++) {

​      for(int j = 0, k = matrix[0].length - 1; j < k; j++, k--) {

​        int temp = matrix[i][j];

​        matrix[i][j] = matrix[i][k];

​        matrix[i][k] = temp;

​      }

​    }

  }

}
```

![image-20220316230958853](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220316230958853.png)

先左上右下翻转然后以中心线对称翻转就可以顺时针旋转90度，只能说太妙了，。

解释：我们观察样例，找规律发现：先以**左上-右下对角条线**为轴做翻转，再以**中心的竖线**为轴做翻转，就可以翻转90度。





## 区间合并问题

#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

![image-20220329220315583](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329220315583.png)

```java
class Solution {

  public int[][] merge(int[][] intervals) {
      int idx = -1;
      int[][] res = new int[intervals.length][2];

      Arrays.sort(intervals,(v1,v2) -> v1[0] - v2[0]);
      for(int[] interval: intervals) {

          if(idx == -1 || interval[0] > res[idx][1]) {
            //如果是第一个或者是遍历到的区间的左值大于结果集最近的右值，那么不用合并了，没有用，因为没有交集
            res[++idx] = interval;
          } else{
            //开始合并
            res[idx][1] = Math.max(res[idx][1],interval[1]); 
          }
      } 
    return Arrays.copyOf(res,idx + 1);
  }
}
```













# 字符串

## DFS

给定两个-100到100的整数x和y,对x只能进行加1，减1，乘2操作，问最少对x进行几次操作能得到y？ 

  例如：
 a=3,b=11: 可以通过3*2*2-1，3次操作得到11；
 a=5,b=8：可以通过(5-1)*2，2次操作得到8；

**输入**

```
3,11
```

**输出**

```java
3
```



```java
DFS
import java.util.Scanner;

    /**
     * @Author: coderjjp
     * @Date: 2020-05-09 18:27
     * @Description:
     * @version: 1.0
     */
    public class Main {
        static Scanner sc = new Scanner(System.in);
        static String s[] = sc.next().split(",");
        static int x = Integer.valueOf(s[0]);
        static int y = Integer.valueOf(s[1]);
        static int min = Math.abs(x - y);//最小值的上界
        public static void main(String[] args) {
            dfs(x, y, 0);
            System.out.println(min);
        }

        private static void dfs(int x, int y, int count) {
            if (count == min)
                return;
            if (x == y){
                /min = Math.min(min,count);
                min = count;
                return;
            }
            dfs(x + 1, y, count + 1);
            dfs(x - 1, y, count + 1);
            dfs(x * 2, y, count + 1);
        }
    }
```



```java
BFS
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {// 注意，如果输入是多个测试用例，请通过while循环处理多个测试用例
            String s= in.next();
            String[] a=s.split(",");
            System.out.println(cishu(Integer.parseInt(a[0]),Integer.parseInt(a[1])));
        }
    }
    static int cishu(int a,int b){
        if (a==b) return 0;
        List<bian> list=new ArrayList<>();
        list.add(new bian(a,0));
        while (!list.isEmpty()){
            bian tem=list.remove(0);
            if (tem.num==b) return tem.ceng;
            else if (tem.num<-100 ||tem.num>100) continue;
            list.add(new bian(tem.num+1,tem.ceng+1));
            list.add(new bian(tem.num-1,tem.ceng+1));
            list.add(new bian(tem.num*2,tem.ceng+1));
        }
        return -1;
    }
    static class bian{
        int num;
        int ceng;
        public bian(int num, int ceng) {
            this.num = num;
            this.ceng = ceng;
        }
    }
}
```





### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)



![image-20220308215900290](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220308215900290.png)



```java
class Solution {
    private String letterMap[] = {
            " ",    //0
            "",     //1
            "abc",  //2
            "def",  //3
            "ghi",  //4
            "jkl",  //5
            "mno",  //6
            "pqrs", //7
            "tuv",  //8
            "wxyz"  //9
    };
    List<String> res;
    public List<String> letterCombinations(String digits) {
        res =  new ArrayList<>();
        if(digits.equals("")) return res;
        dfs(digits,0,"");
        return res;

    }
    public void dfs(String digits, int index, String s){
        if(index == digits.length()) {
            res.add(s);
            return;
        }
        Character c = digits.charAt(index);
        String m = letterMap[c - '0'];

        for(int i = 0; i < m.length(); i++) {
            dfs(digits, index + 1,s + m.charAt(i));
        }
        return;
    }
}
```



![image-20220308220011335](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220308220011335.png)

本题用dfs解决，取字符串的每一位然后其对应的字符串进行字符匹配，不断拼接，如果index加到给定字符串的最后一位时，将拼接的结果加入res集合。

递归树如上图



### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

![image-20220311174524645](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220311174524645.png)



```java
class Solution {

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();

        dfs("",0, 0, n, res);
        return res;
    }
    public void dfs(String s , int left ,int right, int n,List<String> res) {
        //递归终点
        if(left == n && right == n){
            res.add(s);
            return;
        }
        if(left < right){
            return;//减枝
        }
        if(left < n){
            dfs(s + "(",left + 1, right, n,res);
        }
        if(right < n) {
            dfs(s + ")", left, right + 1, n,res);
        }

    }
}
```



dfs递归。递归树如下图

![image-20220311174711411](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220311174711411.png)

n个左括号，n个右括号

递归就是不断用左括号和右括号，用的时候，如果传递的参数左括号数目小于右括号数目（也就是到这一层的时候，左右括号使用的数目），此时要减枝，因为不能出现右括号大于左括号的情况，递归终止的条件，递归树的叶子结点是左括号等于右括号等于n。

还要注意一个条件，要先递归左括号后递归右括号，因为毕竟有效括号是左括号在先









## **BFS**

```java

```







## 子序列



![image-20220309221853980](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220309221853980.png)



```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0,j = 0;
        while(i < s.length() && j  < t.length()){
            if(s.charAt(i) == t.charAt(j)){
                i++;
            }
            j++;
        }
        if(i == s.length())
            return true;
        else
            return false;
    }
}
```

双指针遍历

## 堆栈

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

![image-20220310215709252](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220310215709252.png)

```java
  class Solution {
        public boolean isValid(String s) {
//括号匹配
            if(s.length() % 2 == 1) return false;

            HashMap<Character,Character> map = new HashMap<>(){{
                put(')','(');
                put('}','{');
                put(']','[');
            }};
            //栈
            Deque<Character> stack = new LinkedList<>();

            for(int i = 0; i < s.length(); i++) {

                if(map.containsKey(s.charAt(i))){
                    if(stack.isEmpty() || map.get(s.charAt(i)) != stack.peek()) {
                        return false;
                    }
                    //如果栈顶和现在遍历的元素匹配的话
                    stack.pop();
                }else{
                    stack.push(s.charAt(i));
                }

            }
            return stack.isEmpty();
        }
    }
```



## 双指针

翻转字符串里的单词

![image-20220312220301440](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220312220301440.png)



```java
class Solution {

  public String reverseWords(String s) {

​    StringBuilder str = new StringBuilder();

​    //缩减首尾空格

​    int left = 0, right = s.length() - 1;

​    while( s.charAt(left) == ' ') left++;

​    while(s.charAt(right) == ' ') right--;

​    

​    while(left <= right) {

​    int index = right;
    //不等于空格就一直往左走

​    while(index >= left && s.charAt(index) != ' ') index--;
    //拼接单词

​    for(int i = index + 1; i <= right; i++) str.append(s.charAt(i));

  //如果不是最后一个单词就加上空格

​    if(index > left) str.append(' ');
    //如果遇到多个空格，index跳过，往左边走

​    while(index >= left && s.charAt(index) == ' ') index--;

​    right = index;

​    }

​    return str.toString();

  }
}
```





## 边界问题

### 字符串转整数

![image-20220317231536541](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220317231536541.png)



```java
class Solution {

  public int myAtoi(String s) {

  int number = Integer.MAX_VALUE / 10;

​    char[] c = s.trim().toCharArray();

​    if(c.length == 0) return 0;     

​    int i = 1, sigh = 1;

​    if(c[0] == '-') 

​      sigh = -1;

​    else if(c[0] != '+'){

​      i = 0;

​    }

​    int res = 0;

​    for(int j = i;j < c.length; j++) {

​      if(c[j] < '0' || c[j] > '9') break;

​       if (res > number || (res == number && c[j] > '7')) {

​          //根据字符串首负号判断返回最大值还是最小值

​          return sigh == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;

​        }

​      res = res * 10 + ( c[j] - '0' );

​    }

​    return res * sigh;

  }

}
```



题解：懒得写了，先去空格，用trim(),再继续判断符合，再判断是不是数字，再判断有没有出界，再加数字



![image-20220317232130658](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220317232130658.png)

# 树



## N叉树



### 后序遍历

![image-20220312221124061](../../../../images/%25E5%2588%2586%25E7%25B1%25BB%25E9%25A2%2598%25E7%259B%25AE/image-20220312221124061.png)





```java
/*
// Definition for a Node.

class Node {

  public int val;

  public List<Node> children;

  public Node() {}

  public Node(int _val) {

    val = _val;

  }

  public Node(int _val, List<Node> _children) {

    val = _val;

    children = _children;

  }

};

*/

class Solution {

     List<Integer> ans = new ArrayList<>();

  public List<Integer> postorder(Node root) {

    dfs(root);

    return ans;

  }

  public void dfs(Node root) {

    if(root == null) r;

    for(Node node : root.children) {

      dfs(node);

    }

    ans.add(root.val);

  }

 }
```



## 





## 二叉树

### 最近公共祖先

![image-20220318230109554](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220318230109554.png)





```java
class Solution {



  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

    if (root == null) return null;

    //如果p或者q是root结点,那么公共祖先是root

    if(root.val == p.val || root.val == q.val) return root;



    //如果p和q在左子树

    if(find(root.left,p) && find(root.left,q)) return lowestCommonAncestor(root.left, p, q);

    //如果p和q在右子树

    if(find(root.right, p) && find(root.right,q)) return lowestCommonAncestor(root.right, p, q);

    //如果left和righr在两侧，那root就是最近公共祖先

    return root;

  }

  //单纯理解为一个找结点的函数

  public boolean find(TreeNode root, TreeNode c){

   if (root == null) return false;

   if(root.val == c.val) return true;

   return find(root.left, c) || find(root.right, c);

  }
}
```

这种解法复杂度太高







**下面是最优解**

```java
  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

   if(root == null || root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);

    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if(left == null) return right;

    if(right == null) return left;
    return root;

  }


```

![image-20220318231111565](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220318231111565.png)

个人理解：公共祖先怎样找？ **前序遍历**

5种情况：

1. root等于p或者q，那么直接返回这个root，这个root就是最近公共祖先
2. root.left为null,root.right不为null,说明p和q在右子树上
3. root.left不为null,root.right为null,说明p和q在左子树上
4. root.left和root.right都为null,说明都没有，返回null
5. root.left和root.right都不为null,说明p和q分别在两侧子树上，直接返回root.



### [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)



![image-20220405153457258](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220405153457258.png)



```java
class Solution {
  public boolean isSymmetric(TreeNode root) {

    *if*(root == null) *return* false;

    *return* dfs(root.left,root.right);
  }

  public boolean dfs(TreeNode left, TreeNode right) {

    *//左右都是null,那也对称*

    *if*(left == null && right == null) *return* true;

    *//只有一个为null,不对称*

    *if*(left == null || right == null) *return* false;

    *//两个值不相等，false*

    *if*(left.val != right.val) *return* false;

    *//左子的最左边与右子树的最右边，左子树的右边与右子树的左边*

    *return* dfs(left.left,right.right) && dfs(left.right,right.left);
  }
}
```

判断二叉树是否轴对称，









# 异或运算



异或运算：相同为0，不同为1

同或运算：相同为1，不同为0；



- 异或满足交换律与结合律
- 0 ^ N ==  N        N ^ N == 0



## （1）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎末找到这个数

这题很简单，直接定义一个变量与数组所有元素异或



（2）怎末把一个int类型的数，提取出来最右侧的1

 **eor & (~eor + 1); // 提取出最右的1**

![image-20220322212036217](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220322212036217.png)







## （3）**一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎末找到这个数**

**这个比较难了**



```java
public static void printOddTimesNum2(int[] arr) {
    int eor = 0;
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    // eor = a ^ b
    // eor != 0
    // eor必然有一个位置上是1
    // 0110010000
    // 0000010000
    int rightOne = eor & (~eor + 1); // 提取出最右的1
    int onlyOne = 0; // eor'
    for (int i = 0 ; i < arr.length;i++) {
        //  arr[1] =  111100011110000
        // rightOne=  000000000010000
        if ((arr[i] & rightOne) != 0) {//z1的那个大营
            onlyOne ^= arr[i];
        }
    }
    System.out.println(onlyOne + " " + (eor ^ onlyOne));
} 
```



这个题也是异或做的，先用一个变量eor异或数组所有元素，那么eor最后的值肯定是a ^ b,那此时，怎样分别找出a和b呢，a和b肯定不相同，那它们的某一位异或出来的结果肯定是1（也就是eor的某一位是1），eor是疑惑了所有的元素的，那么，此时将数组所有元素分为这个位是1的和这个位不是1的两大阵营，那么我们重新找个值onlyOne在1的阵营里面不断异或，最后异或出来的结果要么是a要么是b,此时，两个值已经求出一个了，那第二个就用eor^onlyOne就出来了。





# 链表



翻转链表

```java
 public static Node reverseLinkedList(Node head) {

        Node dummy = new Node(-1);

        Node pre = null;

        Node cur = head;

        while(cur != null) {

            pre = cur;

            cur = cur.next;

            pre.next = dummy.next;

            dummy.next = pre;
        }
        return dummy.next;

}
```



 

# 栈和队列

## 栈

**实现一个特殊的栈，在基本功能的基础上，再实现返回栈中最小元素的功能。**（见力扣）





## 队列

 栈和队列只是逻辑名字，底层可以通过双向链表实现和数组实现

双向链表实现队列

数组实现队列

## 栈和队列面试题



**（1）如何用栈实现队列结构**



```java
public class Code06_TwoStacksImplementQueue {
public static class TwoStacksQueue {
	public Stack<Integer> stackPush;
	public Stack<Integer> stackPop;

	public TwoStacksQueue() {
		stackPush = new Stack<Integer>();
		stackPop = new Stack<Integer>();
	}

	// push栈向pop栈倒入数据
	private void pushToPop() {
		if (stackPop.empty()) {
			while (!stackPush.empty()) {
				stackPop.push(stackPush.pop());
			}
		}
	}

	public void add(int pushInt) {
		stackPush.push(pushInt);
		pushToPop();
	}

	public int poll() {
		if (stackPop.empty() && stackPush.empty()) {
			throw new RuntimeException("Queue is empty!");
		}
		pushToPop();
		return stackPop.pop();
	}

	public int peek() {
		if (stackPop.empty() && stackPush.empty()) {
			throw new RuntimeException("Queue is empty!");
		}
		pushToPop();
		return stackPop.peek();
	}
}

public static void main(String[] args) {
	TwoStacksQueue test = new TwoStacksQueue();
	test.add(1);
	test.add(2);
	test.add(3);
	System.out.println(test.peek());
	System.out.println(test.poll());
	System.out.println(test.peek());
	System.out.println(test.poll());
	System.out.println(test.peek());
	System.out.println(test.poll());
}
}
```





**（2）如何用队列结构实现栈结构**

```java
public class Code07_TwoQueueImplementStack {

public static class TwoQueueStack<T> {
	public Queue<T> queue;
	public Queue<T> help;

	public TwoQueueStack() {
		queue = new LinkedList<>();
		help = new LinkedList<>();
	}

	public void push(T value) {
		queue.offer(value);
	}

	public T poll() {
		while (queue.size() > 1) {
			help.offer(queue.poll());
		}
		T ans = queue.poll();
		Queue<T> tmp = queue;
		queue = help;
		help = tmp;
		return ans;
	}

	public T peek() {
		while (queue.size() > 1) {
			help.offer(queue.poll());
		}
		T ans = queue.poll();
		help.offer(ans);
		Queue<T> tmp = queue;
		queue = help;
		help = tmp;
		return ans;
	}

	public boolean isEmpty() {
		return queue.isEmpty();
	}

}

public static void main(String[] args) {
	System.out.println("test begin");
	TwoQueueStack<Integer> myStack = new TwoQueueStack<>();
	Stack<Integer> test = new Stack<>();
	int testTime = 1000000;
	int max = 1000000;
	for (int i = 0; i < testTime; i++) {
		if (myStack.isEmpty()) {
			if (!test.isEmpty()) {
				System.out.println("Oops");
			}
			int num = (int) (Math.random() * max);
			myStack.push(num);
			test.push(num);
		} else {
			if (Math.random() < 0.25) {
				int num = (int) (Math.random() * max);
				myStack.push(num);
				test.push(num);
			} else if (Math.random() < 0.5) {
				if (!myStack.peek().equals(test.peek())) {
					System.out.println("Oops");
				}
			} else if (Math.random() < 0.75) {
				if (!myStack.poll().equals(test.pop())) {
					System.out.println("Oops");
				}
			} else {
				if (myStack.isEmpty() != test.isEmpty()) {
					System.out.println("Oops");
				}
			}
		}
	}

	System.out.println("test finish!");

}
}

```





另一种**写法**(力扣)




```java
class MyStack {
Queue<Integer> queue1;
  Queue<Integer> queue2;

public MyStack() {
    queue1 = new LinkedList<Integer>();
    queue2 = new LinkedList<Integer>();
}

public void push(int x) {

    queue2.offer(x);

    while(!queue1.isEmpty()) {
        queue2.offer(queue1.poll());
    }
    Queue<Integer> temp = queue1;
    queue1 = queue2;
    queue2 = temp;

}

public int pop() {
    return queue1.poll();
}

public int top() {
    return queue1.peek();
}

public boolean empty() {
    return queue1.isEmpty();
}
}
```








# 归并排序

```java
public class Code01_MergeSort {
// 递归方法实现
public static void mergeSort1(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	process(arr, 0, arr.length - 1);
}

// arr[L...R]范围上，变成有序的
// L...R    N    T(N) = 2*T(N/2) + O(N)  ->
public static void process(int[] arr, int L, int R) {
	if (L == R) { // base case
		return;
	}
	int mid = L + ((R - L) >> 1);
	process(arr, L, mid);
	process(arr, mid + 1, R);
	merge(arr, L, mid, R);
}

public static void merge(int[] arr, int L, int M, int R) {
	int[] help = new int[R - L + 1];
	int i = 0;
	int p1 = L;
	int p2 = M + 1;
	while (p1 <= M && p2 <= R) {
		help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
	}
	// 要么p1越界了，要么p2越界了
	while (p1 <= M) {
		help[i++] = arr[p1++];
	}
	while (p2 <= R) {
		help[i++] = arr[p2++];
	}
	for (i = 0; i < help.length; i++) {
		arr[L + i] = help[i];
	}
}

// 非递归方法实现
public static void mergeSort2(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	int N = arr.length;
	int mergeSize = 1;// 当前有序的，左组长度
	while (mergeSize < N) { // log N
		int L = 0;
		// 0.... 
		while (L < N) {
			// L...M  左组（mergeSize）
			int M = L + mergeSize - 1;
			if (M >= N) {
				break;
			}
			//  L...M   M+1...R(mergeSize)
            //找右边界
			int R = Math.min(M + mergeSize, N - 1);
			merge(arr, L, M, R);
			L = R + 1;
		}
		if (mergeSize > N / 2) {
			break;
		}
		mergeSize <<= 1;
	}
}
    
        // 非递归方法实现（手敲）
    public static void mergeSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

        int N = arr.length;
        int mergeSize = 1;
        while (mergeSize < N) {
            int L = 0;

            while (L < N){
                int M = L + mergeSize - 1;
                //左边数不齐mergeSize,这种情况也是发生在最后，不管，因为已经有序
                if(M >= N) break;
                //右边数不齐，这种情况只能是最后
                int R = Math.min(M + mergeSize, N -1);
                merge(arr, L, M, R);
                L = R + 1;
            }
            if(mergeSize > (N / 2)) break;
            mergeSize <<= 1;
        }

    }
```



## 例题

**在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和，求数组小和**

```java
package class03;

public class Code02_SmallSum {
public static int smallSum(int[] arr) {
	if (arr == null || arr.length < 2) {
		return 0;
	}
	return process(arr, 0, arr.length - 1);
}

// arr[L..R]既要排好序，也要求小和返回
// 所有merge时，产生的小和，累加
// 左 排序   merge
// 右 排序  merge
// merge
public static int process(int[] arr, int l, int r) {
	if (l == r) {
		return 0;
	}
	// l < r
	int mid = l + ((r - l) >> 1);
	return 
			process(arr, l, mid) 
			+ 
			process(arr, mid + 1, r) 
			+ 
			merge(arr, l, mid, r);
}

public static int merge(int[] arr, int L, int m, int r) {
	int[] help = new int[r - L + 1];
	int i = 0;
	int p1 = L;
	int p2 = m + 1;
	int res = 0;
	while (p1 <= m && p2 <= r) {
		res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
		help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
	} 
	while (p1 <= m) {
		help[i++] = arr[p1++];
	}
    
	while (p2 <= r) {
		help[i++] = arr[p2++];
	}
    
	for (i = 0; i < help.length; i++) {
		arr[L + i] = help[i];
	}
    
	return res;
}

}
```





**求数组中所有的降序对**(**逆序对**)

```java
class Solution {
int count;
public int reversePairs(int[] nums) {
    this.count = 0;
    merge(nums, 0, nums.length - 1);
    return count;
}

public void merge(int[] nums, int left, int right) {
    int mid = left + ((right - left) >> 1);
    if (left < right) {
        merge(nums, left, mid);
        merge(nums, mid + 1, right);
        mergeSort(nums, left, mid, right);
    }
}     
public void mergeSort(int[] arr, int L, int m, int r) {
	int[] help = new int[r - L + 1];
	int i = 0;
	int p1 = L;
	int p2 = m + 1;
    while (p1 <= m && p2 <= r) {
        count += arr[p1] > arr[p2] ? (m - p1 + 1) : 0;
        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= m) {
        help[i++] = arr[p1++];
    }
    while (p2 <= r) {
        help[i++] = arr[p2++];
    }
    for (i = 0; i < help.length; i++) {
        arr[L + i] = help[i];
    }
}

}
```



归并：纠结当前数右/左边有多少数比当前值大或者小



## 链表排序

![image-20220425222623611](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220425222623611.png)

**递归（自定而下）**

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;

    ListNode first = head, slow = head;

    while(first.next != null && first.next.next != null) {
        first = first.next.next;
        slow = slow.next;
    }

    ListNode h2 = slow.next;

    slow.next = null;

    ListNode left = sortList(head);
    ListNode right = sortList(h2);


    ListNode h = new  ListNode(-1); 

    ListNode dummy = h;
    
    while(left != null && right != null) { 
       
       if(left.val <= right.val) {
           h.next = left;
           left = left.next;
       }else{
           h.next = right;
           right = right.next;
       }

         h = h.next;
    }

    if(left != null) {
        h.next = left;
    }

    if(right != null) {
        h.next = right;
    }

     return dummy.next;
    }
}

```





**非递归（自下而上）**



md，看懵了，谁爱看谁看

```java
class Solution {
     // 自底向上归并排序
    public ListNode sortList(ListNode head) {
        if(head == null){
            return head;
        }

        // 1. 首先从头向后遍历,统计链表长度
        int length = 0; // 用于统计链表长度
        ListNode node = head;
        while(node != null){
            length++;
            node = node.next;
        }

        // 2. 初始化 引入dummynode
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;

        // 3. 每次将链表拆分成若干个长度为subLen的子链表 , 并按照每两个子链表一组进行合并
        for(int subLen = 1;subLen < length;subLen <<= 1){ // subLen每次左移一位（即sublen = sublen*2） PS:位运算对CPU来说效率更高
            ListNode prev = dummyHead;
            ListNode curr = dummyHead.next;     // curr用于记录拆分链表的位置

            while(curr != null){               // 如果链表没有被拆完
                // 3.1 拆分subLen长度的链表1
                ListNode head_1 = curr;        // 第一个链表的头 即 curr初始的位置
                for(int i = 1; i < subLen && curr != null && curr.next != null; i++){     // 拆分出长度为subLen的链表1
                    curr = curr.next;
                }

                // 3.2 拆分subLen长度的链表2
                ListNode head_2 = curr.next;  // 第二个链表的头  即 链表1尾部的下一个位置
                curr.next = null;             // 断开第一个链表和第二个链表的链接
                curr = head_2;                // 第二个链表头 重新赋值给curr
                for(int i = 1;i < subLen && curr != null && curr.next != null;i++){      // 再拆分出长度为subLen的链表2
                    curr = curr.next;
                }

                // 3.3 再次断开 第二个链表最后的next的链接
                ListNode next = null;        
                if(curr != null){
                    next = curr.next;   // next用于记录 拆分完两个链表的结束位置
                    curr.next = null;   // 断开连接
                }

                // 3.4 合并两个subLen长度的有序链表
                ListNode merged = mergeTwoLists(head_1,head_2);
                prev.next = merged;        // prev.next 指向排好序链表的头
                while(prev.next != null){  // while循环 将prev移动到 subLen*2 的位置后去
                    prev = prev.next;
                }
                curr = next;              // next用于记录 拆分完两个链表的结束位置
            }
        }
        // 返回新排好序的链表
        return dummyHead.next;
    }


    // 此处是Leetcode21 --> 合并两个有序链表
    public ListNode mergeTwoLists(ListNode l1,ListNode l2){
        ListNode dummy = new ListNode(0);
        ListNode curr  = dummy;

        while(l1 != null && l2!= null){ // 退出循环的条件是走完了其中一个链表
            // 判断l1 和 l2大小
            if (l1.val < l2.val){
                // l1 小 ， curr指向l1
                curr.next = l1;
                l1 = l1.next;       // l1 向后走一位
            }else{
                // l2 小 ， curr指向l2
                curr.next = l2;
                l2 = l2.next;       // l2向后走一位
            }
            curr = curr.next;       // curr后移一位
        }

        // 退出while循环之后,比较哪个链表剩下长度更长,直接拼接在排序链表末尾
        if(l1 == null) curr.next = l2;
        if(l2 == null) curr.next = l1;

        // 最后返回合并后有序的链表
        return dummy.next; 
    }
}
```



## 合并k个有序链表

先分再合



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists == null || lists.length == 0) return null;


        return mergeHelp(lists, 0, lists.length - 1);
 

    }

    public ListNode mergeHelp(ListNode[] list,int l, int r) {
     if(l == r) {
         return list[l];
     }
     if(l > r) {
         return null;
     }

     int mid = (l + r) / 2;

     ListNode left = mergeHelp(list, l, mid);
     ListNode right = mergeHelp(list, mid + 1, r);

     return mergeTwoLists(left, right);
    }
    
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

        ListNode dummy = new ListNode(-1);
        ListNode temp = dummy;
        while (l1 != null && l2 != null) {
            if(l1.val < l2.val) {
            temp.next = l1;
            l1 = l1.next;
            }else {
            temp.next = l2;
            l2 = l2.next;
            }
            temp = temp.next;
        }

        if(l1 != null) {
            temp.next = l1;
        }
        if(l2 != null) {
            temp.next = l2;
        }
        return dummy.next;
    }

}
```



#  快排



## 具体步骤

- （1）选择A中的任意一个元素pivot，该元素作为基准
- （2）将小于基准的元素移到左边，大于基准的元素移到右边（分区操作）
- （3）A被pivot分为两部分，继续对剩下的两部分做同样的处理
- （4）直到所有子集元素不再需要进行上述步骤





**自己理解**

```java
public static void QuickSort(int[] arr,int low,int high){
        if(low>=high)
            return;
        int i=low,j=high;
        //基准值，一般来说取第一个为基准值
        int p=arr[low];
        int temp;//先记录基准值，最后要交换
        while (i<j){
            //一定是先从右边走，找比基准值小的值
            while (i<j&&arr[j]>=p){
                j--;
            }
            while (i<j&&arr[i]<=p){
                i++;
            }
            //交换相遇值
            temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
        }
        //交换相遇值和基准值，这样基准值左边都是比他小的，右边都是比他大的
        arr[low]=arr[i];  
        arr[i]=p;
        //递归 
        QuickSort(arr,low,i-1);
        QuickSort(arr,i+ 1,high); 
    }
```

## [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

![image-20220330230230289](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220330230230289.png)





```java
class Solution {

  public void sortColors(int[] nums) {

​      if(nums.length < 2) return;

​      int zero = 0;

​      int two = nums.length;

​      int i = 0;

​      while(i < two) {

​        if(nums[i] == 0) {

​          swap(nums,i,zero);

​          zero++;

​          i++;

​        }else if (nums[i] == 1) {

​          i++;

​        }else{

​          two--;

​          swap(nums,i,two);

​        }

​      }

  }

  public void swap(int[] arr, int i, int j) {

​    int temp = arr[i];

​    arr[i] = arr[j];

​    arr[j] = temp;

  }

}
```











## [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

![image-20220419153932183](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220419153932183.png)



```java
class Solution {
    public int findKthLargest(int[] nums, int k) {

        int from = 0, to = nums.length - 1;
         while(true) {
                int x = partion(nums, from, to);
                if(x == k - 1) return nums[x];
                else if(x > k -1 ) to = x - 1; 
                else from = x + 1; 
         }         
    }

    public int partion(int[] nums, int from, int to) {

      int left = from, right = to;
      int pivot = nums[from];

        while(left < right) {   
            while(left < right && nums[right] <= nums[from]) {
                right--;
            }
            while(left < right && nums[left] >= nums[from]){
                left++;
            }
            if(left < right) 

            swap(nums,left,right);

        }

          swap(nums,from, left);

        return left;

    }

    public void swap(int[] nums, int p, int q) {
        int temp = nums[p];
        nums[p] = nums[q];
        nums[q] = temp;
    }

}
```



# 桶排



## 前k个高频元素

![image-20220419163603900](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220419163603900.png)





### ①小根堆+HashMap

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
       
       Map<Integer,Integer> map = new HashMap<>();
      for(int num : nums) {
          if(map.containsKey(num)) {
              map.put(num,map.get(num) + 1);
          }else{
               map.put(num,1);
          }
      }

         PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });



      for(Integer m:map.keySet()){
           

           if(pq.size() < k) {
               pq.add(m);
           }else{
               if(map.get(m) > map.get(pq.peek())) {
                   pq.poll();
                   pq.add(m);
               }
           } 
       }

       int[] res = new int[k];
       int j = 0;
       while(!pq.isEmpty()) {
         res[j++] = pq.poll();
       }
       return res;
    }
}
```



### ②桶排序 + HashMap

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
       
       Map<Integer,Integer> map = new HashMap<>();
      for(int num : nums) {
          if(map.containsKey(num)) {
              map.put(num,map.get(num) + 1);
          }else{
               map.put(num,1);
          }
      }

         PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer a, Integer b) {
                return map.get(a) - map.get(b);
            }
        });


    List<Integer> res = new LinkedList<>();


    List<Integer>[] list = new List[map.size() + 1];


    for(Integer m : map.KeySet()) {

            int i = map.get(key);
            if(list[i] == null){
               list[i] = new ArrayList();
            } 
            list[i].add(key);
    }


    for(int i = map.size(); i >= 0 && res.size() < k; i-- ) {
        if(list[i] == null) continue;
        res.addAll(list[i]);
    }

       return res;
    }
}
```

## **桶排序时间复杂度**

平均情况下，桶排序的时间复杂度为 O(n)。

最坏情况下，所有数据都放到同一个桶内，桶排序的时间复杂度为 O(n^2) 或 O(n * lg n)，这取决于桶内元素自排序的算法





# 堆

 

每个结点的左孩子是2*i + 1，右孩子是2*i + 2,父结点是(i - 1) / 2;

 ![image-20220328193916276](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328193916276.png)





## 堆排

```java
public class Code04_HeapSort {
// 堆排序额外空间复杂度O(1)
public static void heapSort(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	// O(N*logN)
//		for (int i = 0; i < arr.length; i++) { // O(N)//经典堆排序
//			heapInsert(arr, i); // O(logN)//从上往下建堆
//		}
    
    
    //构建大根堆，时间复杂度是O(N)
	 	for (int i = arr.length - 1; i >= 0; i--) {//优化
			heapify(arr, i, arr.length);//从下往上建堆
		}
    
    
    
    
		int heapSize = arr.length;
		swap(arr, 0, --heapSize);
		// 堆排序，时间复杂度是nlog(N)
		while (heapSize > 0) { // O(N)  
			heapify(arr, 0, heapSize); // O(logN)
			swap(arr, 0, --heapSize); // O(1) 
		}
    
    
    
    
	}
// arr[index]刚来的数，往上
    //这个也就说是构建大根堆

//    public static void heapInsert(int[] arr, int index) {
//        while (arr[index] > arr[(index - 1) / 2]) {//大于父结点
//            swap(arr, index, (index - 1) / 2); //就交换，然后，不断网上看是否大于父结点 
//            index = (index - 1) / 2;
//        }
//    }

// arr[index]位置的数，能否往下移动
public static void heapify(int[] arr, int index, int heapSize) {
	int left = index * 2 + 1; // 左孩子的下标
	while (left < heapSize) { // 下方还有孩子的时候
		// 两个孩子中，谁的值大，把下标给largest
		// 1）只有左孩子，left -> largest
		// 2) 同时有左孩子和右孩子，右孩子的值<= 左孩子的值，left -> largest
		// 3) 同时有左孩子和右孩子并且右孩子的值> 左孩子 的值， right -> largest
		int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
		// 父和较大的孩子之间，谁的值大，把下标给largest
		largest = arr[largest] > arr[index] ? largest : index;
		if (largest == index) {
			break;
		}
		swap(arr, largest, index);
		index = largest;
		left = index * 2 + 1;
	}
}

public static void swap(int[] arr, int i, int j) {
	int tmp = arr[i];
	arr[i] = arr[j];
	arr[j] = tmp; 
}

}
```



 **堆排序分为两大部分（以升序为例子）**

- 建立大顶堆
- 交换大顶堆元素和重建堆



给的一个无序数组其实就相当于一颗完全二叉树，构建大顶堆就在这颗完全二叉树上建立。





1. 在for循环里面从第一个元素开始，一个一个遍历元素来构建大顶堆（也就是从第一个结点开始来构建），具体就是在for循环里面不断调用heapify(int[] arr, int index)来构建大顶堆。遍历到哪个结点就不断与父结点比较（也就是不断网上比较），不断比较，知道当前结点小于父结点。

   

2. 构建完大顶堆只后，然后不断交换后面的元素与大顶堆根结点（大顶堆根结点是不断变化的），交换完之后再调用heapify(int[] arr, int index, int heapSize)来维护大顶堆。

   

3. 这个heapify逻辑是什么，不断往下比较，看arr[index]位置的数，能否往下移动，也就是不断比较父亲结点与“两个孩子结点比较出来的大值”并且交换。直到当前结点的孩子出界（也就是left > heapSize）



java中的优先队列，底层就是堆，默认是小根堆，如果想改成大根堆的话，重写比较器。例子如下图所示。



![image-20220328212709424](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328212709424.png)



## 堆时间复杂度



构建堆的时间复杂度按上面的解法的O(N),

> 假如有N个节点，那么高度为H=logN，最后一层每个父节点最多只需要下调1次，倒数第二层最多只需要下调2次，顶点最多需要下调H次，而最后一层父节点共有2^(H-1)个,倒数第二层公有2^(H-2),顶点只有1(2^0)个，所以总共的时间复杂度为s = 1 * 2^(H-1) + 2 * 2^(H-2) + ... + (H-1) * 2^1 + H * 2^0
>
> 将H代入后s= 2N - 2 - log2(N)，近似的时间复杂度就是O(N)。
>
> 经评论提醒，H=log2(N)  +  1



**完全二叉树从最下层最右边的非终端结点开始构建，将它与其孩子进行比较和若有必要的互换，对于每个非终端结点来说，其实最多进行两次比较和互换操作，因此整个构建堆的时间复杂度是O(n).**




堆排序时间复杂度是nlog(N):因为重建堆是logN,外面不断交换的O(N),合起来是nlog(n)

**看知乎解释**：https://www.zhihu.com/question/20729324



### 构建堆

![image-20220719203615189](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220719203615189.png)





### 堆排序

![image-20220719203625891](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220719203625891.png)













##  大小顶堆



## 求中位数

![image-20220427221554536](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220427221554536.png)

**解决;**



1. 维护一个大顶堆和小顶堆，大顶堆存放数据较小一半的树，小顶堆存放数据较大一半的数。



2. 如果是奇数，中位数放进小顶堆，即中位数是小顶堆堆顶元素



3. 如果是偶数，两个堆堆顶数除以2



4. **放元素步骤**

- 当两堆总大小为偶数时，即两堆大小相等，先将新元素插入maxHeap，重新排序后将新的最值拿出并插入到minHeap；

- 当两堆总大小为奇数时，即两堆大小不等，先将新元素插入minHeap，重新排序后将新的最值拿出并插入到maxHeap；



```java
class MedianFinder {

          // 大顶堆存储较小一半的值
    PriorityQueue<Integer> maxHeap;
    // 小顶堆存储较大一般的值
    PriorityQueue<Integer> minHeap;



    /** initialize your data structure here. */
    public MedianFinder() {
        minHeap = new PriorityQueue<>();
        maxHeap = new PriorityQueue<>( (x, y) -> (y - x));
    }
    
    public void addNum(int num) {
        if(maxHeap.size() != minHeap.size()) { //为奇数
        //先到小堆，然后再进大堆
        minHeap.add(num);
        maxHeap.add(minHeap.poll());

        } else{
            //为偶数
            //先进大堆再进小堆
            //为了维护大小堆之间的数据有序
        maxHeap.add(num);
        minHeap.add(maxHeap.poll());    

        }

    }
    
    public double findMedian() {
        if(maxHeap.size() != minHeap.size()) {//奇数
          return minHeap.peek();
        }else {
          return (minHeap.peek() + maxHeap.peek()) / 2.0;
        }

    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```





# 比较器



![image-20220328211810970](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328211810970.png)





![image-20220328212416005](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328212416005.png)







# 子集与排列

![image-20220331091937669](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220331091937669.png)



```java
class Solution {
   List<List<Integer>> res = new ArrayList<>();

​    List<Integer> path = new LinkedList<>();

  public List<List<Integer>> subsets(int[] nums) {

​      dfs(nums,path,0);

​      return res;

  }

  public void dfs(int[] nums,List<Integer> path,int start) {

​     res.add(new ArrayList<Integer>(path));

   for(int i = start; i < nums.length; i++){

​     path.add(nums[i]);

​     dfs(nums,path,i+1);

​     path.remove(path.size()-1);

   }

  }

}
```

![image-20220331092040640](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220331092040640.png)

递归＋回溯



排列与子集不一样：【1，2】与【2，1】是一个集合/子集 但不是一个排列b 



同一树层不能重复取

**子集2**

这个主要是去重

```java
class Solution {
     List<List<Integer>> res = new ArrayList<>();

     LinkedList<Integer> path = new LinkedList<>()；

  public List<List<Integer>> subsetsWithDup(int[] nums) {

      Arrays.sort(nums);

      boolean[] used = new boolean[nums.length];
      dfs(nums,0,used);

      return res;

  }

  public void dfs(int[] nums,int start,boolean[] used) {

    res.add(new ArrayList<Integer>(path));

    if(start >= nums.length ) return;

    for(int i = start; i < nums.length; i++) {

      //去重，主要是为了同一树层不重复，而同一树枝可以重复，num[i] == num[i - 1]相等并且i-1必须用过，因为只有树枝相同的元素才能重复用，同一树层相同的元素不能重复用

      if(i > 0 && nums[i] == nums[i - 1] && !used[i - 1])

      continue;

      used[i] = true; 

      path.add(nums[i]);

      dfs(nums,i + 1,used);

      path.removeLast();

      used[i] = false;

    } 

  }

}
```

## 全排列

![image-20220418192944047](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220418192944047.png)



```java
class Solution {

   List<List<Integer>> res = *new* ArrayList<>(); 

   LinkedList<Integer> path = *new* LinkedList<>(); 

​    boolean[] used;

  public List<List<Integer>> permute(int[] nums) {



​    used = *new* boolean[nums.length];

​    dfs(nums);

​    *return* res;

  }

  public void dfs(int[] nums) {

​    

​    *if*(path.size() == nums.length) {

​      res.add(*new* ArrayList<>(path));

​      *return*;

​    }

​    *//开始分层递归*

  *for*(int i = 0; i < nums.length; i++) {

​    *if*(used[i]) {

​      *continue*;

​    }

​    used[i] = true;

​    path.add(nums[i]);

​    dfs(nums);

​    path.removeLast();

​    used[i] = false;



  }

  }

}


```





# 子序列与子数组

返回字符串的所有子序列，且不重复.

```java
   import java.util.*;
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string字符串 
     * @return string字符串一维数组
     */
    public String[] generatePermutation (String s){
   char[] str = s.toCharArray();
    List<String> res = new LinkedList<>();
    HashSet<String> set = new HashSet();
    
    process(str,0,set,"");
    
    //String[] m = (String)res.toArray();
    
    for(String gg : set) {
        res.add(gg);
    }
        
    String[] strArray = res.toArray(new String[res.size()]);
     
    return strArray;
    // write code here
}
public static void process(char[] str, int index, HashSe t<String> ans, String path) {
    if(index == str.length) {
        ans.add(path);
        return;
    }
    
    String no = path;
    process(str,index + 1,ans,no);
    
    String yes = path + String.valueOf(str[index]);
    
    process(str, index + 1,ans, yes);
    }
  }
```


​        

## 递归加回溯

```java
class Solution {
    boolean[][] used;
    public static final int[][] temp = new int[][] {{0,1},{0,-1},{1,0},{-1,0}};
    private char[] charArray;
    public boolean exist(char[][] board, String word) {
        charArray = word.toCharArray();
        // int index = 0;
        used = new boolean[board.length][board[0].length];

        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(i, j, 0, board)) {
                    return true;
                }
            }
        }
        return false;
    }
    public boolean dfs(int x,int y, int index, char[][] board) {
        if(index == charArray.length - 1)
            return board[x][y] == charArray[index];
        //判断是否出界
        if(board[x][y] == charArray[index]){//说明当前元素是对的
            //先标记用过了这个元素
            used[x][y] = true;
            //开始走下一步，遍历自己周围。走过的就不能走了，超过边界的也不能走
            for(int[]m :temp) {
                int newX = x + m[0];
                int newY = y +  m[1];
                if( isSide(newX, newY, board) && !used[newX][newY]) {//保证没出界并且没用过
                    if(dfs(newX, newY,index + 1 ,board)) return true;
                }
            }
            //标记回没用过，因为到这一步，说明，当前元素是对的，但是它周围都走不通，所以标记回没有用过，说不定其他路径可以用。
            used[x][y] = false;
        }
        return false;
    }
    public boolean isSide(int x, int y, char[][] board) {
        return x >= 0 && x < board.length && y >= 0 && y < board[0].length;
    }
}
```





# 二叉树搜索树

**1.不同的二叉搜索树**



![image-20220403181758285](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220403181758285.png)





**不知道从哪整出来的卡特兰树，反正学到了**

卡特兰树

G(n) = G(0)*G( n -1) * G(1) * G(n - 2) + ......+ G(n - 1) * G(0)

```java
class Solution {
    public int numTrees(int n) {
       int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i < n + 1; i++) {
            for(int j = 0; j < i ; j++) {
                dp[i] += dp[j ] * dp[ i - j - 1];
            }
        }
        return dp[n];
    }
}
```

**自己改的版本（略改）**





**2.验证二叉搜索树**

![image-20220405150839136](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220405150839136.png)





```java
class Solution {
//如果根节点的左子树为空，保证root.val <= pre条件不成立，因为这也可能是二叉搜索树
  long pre = Long.MIN_VALUE;

  boolean res = true;

  public boolean isValidBST(TreeNode root) {

    dfs(root);

    *return* res;

  }
  public void dfs(TreeNode root) {

    *if*(root == null) *return*;

    dfs(root.left);

    *if*(root.val <= pre) {
      res = false;
      *return*;

    }*else*{//root.val > pre,说明当前结点大于前一个结点符合条件，pre跌代到下一个

      pre = root.val;

    }

    dfs(root.right);

  }

}
```









# 并查集

今天做了第一道并查集题

## 判断图中两个点是否有有效路径



![image-20220405224552528](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220405224552528.png)



```java
class Solution {
  public boolean validPath(int n, int[][] edges, int start, int end) {

    *//用的什么狗屁并查集，寄*

     bingchaji b = *new* bingchaji(n);

     *for*(int i = 0; i < edges.length; i++) {

       b.merge(edges[i][0],edges[i][1]);
     }
    *return* b.isConnected(start,end);
  }
  class bingchaji{
  int size;
  int[] parent;
      
    public bingchaji(int n) {
      
      this.size = n;

      parent = *new* int[size];

      *for*(int i = 0; i < parent.length; i++) {

        *//所有人都是教主*

        parent[i] = i;

      }

    }

    *//查询教主*

    public int find(int x) {

      *while*(parent[x] != x) {

        x = parent[x];

      }

      *return* x;

    }

    public void merge(int x, int y) {

      int x1 = find(x);

      int y1 = find(y);

      *if*(x1 == y1) *return*;

      parent[x1] = y1;

    }

    *//核心函数判断是否在同一个教主下*

    public boolean isConnected(int x, int y) {

      *return* find(x) == find(y);

    }

  }

}
```

## 图中有多少个联通分量

![image-20220407224549195](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220407224549195.png)



​    


```java
class Solution {
public int findCircleNum(int[][] isConnected) {
      bingchaji b = new bingchaji(isConnected.length);

    for(int i = 0; i < isConnected.length; i++) {
        for(int j = i + 1; j < isConnected.length; j++) {
            if(isConnected[i][j] == 1) {//说明相连，那就连起来
                    b.merge(i,j);
            }
        }
    }
   return b.size;
}

class bingchaji{
    int[] partent;
    int size;
    public bingchaji(int n) {
        //初始化老大
        this.partent = new int[n];
        this.size = n;//设初始值有n个联通分枝

    for(int i = 0; i < n; i++) {
        partent[i] = i;
    }

    }
    public int find(int x) {
         while(partent[x] != x) {
             x = partent[x];
         }
         return x;
         }

    public void merge(int x, int y) {
        int x1 = find(x);
        int y1 = find(y);
        if(x1 != y1) {
            partent[x1] = y1;//合并两个老大
            size--;//联通分枝减一个
        }
    }
   }
 }
```


​            











# 前缀树



**概念介绍**

![image-20220406200241012](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220406200241012.png)



有个pass值和end值

 

​    



**code**



```java
package class05;

import java.util.HashMap;

// 该程序完全正确
public class Code02_TrieTree {
public static class Node1 {
	public int pass;
	public int end;
	public Node1[] nexts;

	public Node1() {
		pass = 0;
		end = 0;
		// 0    a
		// 1    b
		// 2    c
		// ..   ..
		// 25   z
		// nexts[i] == null   i方向的路不存在
		// nexts[i] != null   i方向的路存在
		nexts = new Node1[26];
	}
}

public static class Trie1 {
	private Node1 root;

	public Trie1() {
		root = new Node1();
	}

	public void insert(String word) {
		if (word == null) {
			return;
		}
		char[] str = word.toCharArray();
		Node1 node = root;
		node.pass++;
		int path = 0;
		for (int i = 0; i < str.length; i++) { // 从左往右遍历字符
			path = str[i] - 'a'; // 由字符，对应成走向哪条路
			if (node.nexts[path] == null) {
				node.nexts[path] = new Node1();
			}
			node = node.nexts[path];
			node.pass++;
		}
		node.end++;
	}

	public void delete(String word) {
		if (search(word) != 0) {
			char[] chs = word.toCharArray();
			Node1 node = root;
			node.pass--;
			int path = 0;
			for (int i = 0; i < chs.length; i++) {
				path = chs[i] - 'a';
				if (--node.nexts[path].pass == 0) {
					node.nexts[path] = null;
					return;
				}
				node = node.nexts[path];
			}
			node.end--;
		}
	}

	// word这个单词之前加入过几次
	public int search(String word) {
		if (word == null) {
			return 0;
		}
		char[] chs = word.toCharArray();
		Node1 node = root;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = chs[i] - 'a';
			if (node.nexts[index] == null) {
				return 0;
			}
			node = node.nexts[index];
		}
		return node.end;
	}

	// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的
	public int prefixNumber(String pre) {
		if (pre == null) {
			return 0;
		}
		char[] chs = pre.toCharArray();
		Node1 node = root;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = chs[i] - 'a';
			if (node.nexts[index] == null) {
				return 0;
			}
			node = node.nexts[index];
		}
		return node.pass;
	}
}

public static class Node2 {
	public int pass;
	public int end;
	public HashMap<Integer, Node2> nexts;

	public Node2() {
		pass = 0;
		end = 0;
		nexts = new HashMap<>();
	}
}

public static class Trie2 {
	private Node2 root;

	public Trie2() {
		root = new Node2();
	}

	public void insert(String word) {
		if (word == null) {
			return;
		}
		char[] chs = word.toCharArray();
		Node2 node = root;
		node.pass++;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = (int) chs[i];
			if (!node.nexts.containsKey(index)) {
				node.nexts.put(index, new Node2());
			}
			node = node.nexts.get(index);
			node.pass++;
		}
		node.end++;
	}

	public void delete(String word) {
		if (search(word) != 0) {
			char[] chs = word.toCharArray();
			Node2 node = root;
			node.pass--;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = (int) chs[i];
				if (--node.nexts.get(index).pass == 0) {
					node.nexts.remove(index);
					return;
				}
				node = node.nexts.get(index);
			}
			node.end--;
		}
	}

	// word这个单词之前加入过几次
	public int search(String word) {
		if (word == null) {
			return 0;
		}
		char[] chs = word.toCharArray();
		Node2 node = root;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = (int) chs[i];
			if (!node.nexts.containsKey(index)) {
				return 0;
			}
			node = node.nexts.get(index);
		}
		return node.end;
	}

	// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的
	public int prefixNumber(String pre) {
		if (pre == null) {
			return 0;
		}
		char[] chs = pre.toCharArray();
		Node2 node = root;
		int index = 0;
		for (int i = 0; i < chs.length; i++) {
			index = (int) chs[i];
			if (!node.nexts.containsKey(index)) {
				return 0;
			}
			node = node.nexts.get(index);
		}
		return node.pass;
	}
}

public static class Right {

	private HashMap<String, Integer> box;

	public Right() {
		box = new HashMap<>();
	}

	public void insert(String word) {
		if (!box.containsKey(word)) {
			box.put(word, 1);
		} else {
			box.put(word, box.get(word) + 1);
		}
	}

	public void delete(String word) {
		if (box.containsKey(word)) {
			if (box.get(word) == 1) {
				box.remove(word);
			} else {
				box.put(word, box.get(word) - 1);
			}
		}
	}

	public int search(String word) {
		if (!box.containsKey(word)) {
			return 0;
		} else {
			return box.get(word);
		}
	}

	public int prefixNumber(String pre) {
		int count = 0;
		for (String cur : box.keySet()) {
			if (cur.startsWith(pre)) {
				count += box.get(cur);
			}
		}
		return count;
	}
}

// for test
public static String generateRandomString(int strLen) {
	char[] ans = new char[(int) (Math.random() * strLen) + 1];
	for (int i = 0; i < ans.length; i++) {
		int value = (int) (Math.random() * 6);
		ans[i] = (char) (97 + value);
	}
	return String.valueOf(ans);
}

// for test
public static String[] generateRandomStringArray(int arrLen, int strLen) {
	String[] ans = new String[(int) (Math.random() * arrLen) + 1];
	for (int i = 0; i < ans.length; i++) {
		ans[i] = generateRandomString(strLen);
	}
	return ans;
}

public static void main(String[] args) {
	int arrLen = 100;
	int strLen = 20;
	int testTimes = 100000;
	for (int i = 0; i < testTimes; i++) {
		String[] arr = generateRandomStringArray(arrLen, strLen);
		Trie1 trie1 = new Trie1();
		Trie2 trie2 = new Trie2();
		Right right = new Right();
		for (int j = 0; j < arr.length; j++) {
			double decide = Math.random();
			if (decide < 0.25) {
				trie1.insert(arr[j]);
				trie2.insert(arr[j]);
				right.insert(arr[j]);
			} else if (decide < 0.5) {
				trie1.delete(arr[j]);
				trie2.delete(arr[j]);
				right.delete(arr[j]);
			} else if (decide < 0.75) {
				int ans1 = trie1.search(arr[j]);
				int ans2 = trie2.search(arr[j]);
				int ans3 = right.search(arr[j]);
				if (ans1 != ans2 || ans2 != ans3) {
					System.out.println("Oops!");
				}
			} else {
				int ans1 = trie1.prefixNumber(arr[j]);
				int ans2 = trie2.prefixNumber(arr[j]);
				int ans3 = right.prefixNumber(arr[j]);
				if (ans1 != ans2 || ans2 != ans3) {
					System.out.println("Oops!");
				}
			}
		}
	}
	System.out.println("finish!");

}
}
```



## 力扣实现前缀树

![image-20220406215124154](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220406215124154.png)


```java
class Trie {
    private Node root;
    public Trie() {
           root = new Node(); 
    }
    
public void insert(String word) {

    Node node = root;
    node.pass++;

    int path = 0;
    for(int i = 0; i < word.length(); i++) {
        path = word.charAt(i) - 'a';
        if(node.nexts[path] == null) {
            node.nexts[path] = new Node();
        }

        node = node.nexts[path];
        node.pass++;
    }
    node.end++;
}

public boolean search(String word) {
    Node node = root;
    int index = 0;
    for(int i = 0; i < word.length(); i++) {
        index = word.charAt(i) - 'a';
        if(node.nexts[index] == null) {
            return false;
        }
        node = node.nexts[index];
    }
    if(node.end != 0)
    return true;
    else
    return false;
}

public boolean startsWith(String prefix) {
    Node node = root;
    int index = 0;
    for(int i = 0; i < prefix.length(); i++) {
        index = prefix.charAt(i) - 'a';
        if(node.nexts[index] == null) {
            return false;
        }
        node = node.nexts[index];
    }
    return true;
}

class Node{
    public int pass;
    public int end;
    public Node[] nexts;
    public Node() {
            pass = 0;
            end = 0;
            nexts = new Node[26];
    }
}
}
```












# 链表

 

## 链表找中点

```java
ListNode findMid(ListNode head) {
    ListNode fast = head, slow =head;
    while(fast.next != null && fast.next.next!= null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```



**将单向链表按某值分为左边小，中间相等、右边大的形式**

![image-20220407195921407](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220407195921407.png)

```java
public static Node listPartition2(Node head, int pivot) {
	Node sH = null; // small head
	Node sT = null; // small tail
	Node eH = null; // equal head
	Node eT = null; // equal tail
	Node mH = null; // big head
	Node mT = null; // big tail
	Node next = null; // save next node
	// every node distributed to three lists
	while (head != null) {
		next = head.next;
		head.next = null;
		if (head.value < pivot) {
			if (sH == null) {
				sH = head;
				sT = head;
			} else {
				sT.next = head;
				sT = head;
			}
		} else if (head.value == pivot) {
			if (eH == null) {
				eH = head;
				eT = head;
			} else {
				eT.next = head;
				eT = head;
			}
		} else {
			if (mH == null) {
				mH = head;
				mT = head;
			} else {
				mT.next = head;
				mT = head;
			}
		}
		head = next;
	}
	// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头
	if (sT != null) { // 如果有小于区域
		sT.next = eH;
		eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
	}
	// 上面的if，不管跑了没有，et
	// all reconnect
	if (eT != null) { // 如果小于区域和等于区域，不是都没有
		eT.next = mH;
	}
	return sH != null ? sH : (eH != null ? eH : mH);
}
```



## 翻转链表

**给定头结点，和left 和right 翻转left与right之间的结点、**

```java
public static Node reverse2(Node head,int left, int right) {

    Node temp = head;
    for(int i = 0; i < left - 1; i++) {
        temp = temp.next;
    }
    Node cur = temp;
    Node pre = null;

    for(int j = 0; j < right - left; j++) {
        pre = cur;
        cur = cur.next;
        pre.next = temp.next;
        temp.next = pre;
    }
    return head;
}
```



## 链表找环的入口结点

![image-20220409112116118](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220409112116118.png)



```java
public class Solution {

  public ListNode detectCycle(ListNode head) {  

    ListNode fast=head;

    ListNode slow=head;

    *while*(fast!=null&&fast.next!=null){

      fast=fast.next.next;
      slow=slow.next;

      *if*(slow==fast){

         fast=head;

    *while*(fast!=slow){

      slow=slow.next;

      fast=fast.next;

    }

     *return* fast;

      }

    }

    *return* null;

  }

}
```



**解法**:本题解法是快慢指针，先让快指针走两步，慢指针走一步，最后两个指针一定会在环内某个点相遇，这时候快指针移动到头结点，然后两个都是慢指针走1步，最后一定会在环结点相遇（证明谁爱看谁看）

## 两个链表的第一个相交结点

![image-20220409112915056](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220409112915056.png)

```java
  public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

  *//  是题解的浪漫双指针法，太6了*

  ListNode boy=headA,girl=headB;

  *while*(boy!=girl){

    boy=boy!=null*?*boy.next*:*headB;

    girl=girl!=null*?*girl.next*:*headA;

  }

  *return* boy;

  }
```

**解法**：这个主要是为了让两个指针走的举例一样





# 二叉树

##  二叉树两个结点的最短路径









## 从前序与中序遍历序列构造二叉树

![image-20220409140649485](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220409140649485.png)

```java
class Solution {

  HashMap<Integer,Integer> map;

  public TreeNode buildTree(int[] preorder, int[] inorder) {

    map = *new* HashMap<>();



    *for*(int i = 0; i < inorder.length; i++) {

      map.put(inorder[i],i);

    }



    *//不断递归，缩小树范围，将二叉树不断分成小规模树进行解决问题。 int pre_left -- 先序遍历树的左边, int pre_right先序遍历树的右边,int in_left中序遍历树的左边, int in_right中序遍历树的右边*

    *return* mybuildTree(preorder,inorder, 0, preorder.length - 1, 0, inorder.length);

  }

  public TreeNode mybuildTree(int[] preorder, int[] inorder, int pre_left, int pre_right,int in_left, int in_right) {

    *if*(pre_left > pre_right) *return* null;



    int root_val = preorder[pre_left];*//先序的第一个元素一定是根结点*

    TreeNode root = *new* TreeNode(root_val);

    *//左子树的长度*

    int left_length = map.get(preorder[pre_left]) - in_left;*//这个in_left是中序遍历的第一个元素（左根右）*

    int root_in = map.get(preorder[pre_left]);

    *//递归，为当前建立的根结点找左右子树*

​    *//先找左子树*

​    *//pre_left + 1代表先序遍历，当前根结点左子树的起始位置,pre_left + left_length代表当前根结点左子树的结束位置*

​    root.left = mybuildTree(preorder, inorder, pre_left + 1,pre_left + left_length,in_left,root_in - 1);

​    *//再找右子树*

​    root.right = mybuildTree(preorder, inorder,pre_left + left_length + 1,pre_right,root_in + 1, in_right);

​    *return* root;

  }  

}
```



## 找到二叉树中的最大搜索二叉子树





```java

package class08;

import java.util.ArrayList;

public class Code05_MaxSubBSTHead {
public static class Node {
	public int value;
	public Node left;
	public Node right;

	public Node(int data) {
		this.value = data;
	}
}

public static int getBSTSize(Node head) {
	if (head == null) {
		return 0;
	}
	ArrayList<Node> arr = new ArrayList<>();
	in(head, arr);
	for (int i = 1; i < arr.size(); i++) {
		if (arr.get(i).value <= arr.get(i - 1).value) {
			return 0;
		}
	}
	return arr.size();
}

public static void in(Node head, ArrayList<Node> arr) {
	if (head == null) {
		return;
	}
	in(head.left, arr);
	arr.add(head);
	in(head.right, arr);
}

public static Node maxSubBSTHead1(Node head) {
	if (head == null) {
		return null;
	}
	if (getBSTSize(head) != 0) {
		return head;
	}
	Node leftAns = maxSubBSTHead1(head.left);
	Node rightAns = maxSubBSTHead1(head.right);
	return getBSTSize(leftAns) >= getBSTSize(rightAns) ? leftAns : rightAns;
}

public static Node maxSubBSTHead2(Node head) {
	if (head == null) {
		return null;
	}
	return process(head).maxSubBSTHead;
}

// 每一棵子树
public static class Info {
	public Node maxSubBSTHead;
	public int maxSubBSTSize;
	public int min;
	public int max;

	public Info(Node h, int size, int mi, int ma) {
		maxSubBSTHead = h;
		maxSubBSTSize = size;
		min = mi;
		max = ma;
	}
}

public static Info process(Node X) {
	if (X == null) {
		return null;
	}
	Info leftInfo = process(X.left);
	Info rightInfo = process(X.right);
	int min = X.value;
	int max = X.value;
	Node maxSubBSTHead = null;
	int maxSubBSTSize = 0;
	if (leftInfo != null) {
		min = Math.min(min, leftInfo.min);
		max = Math.max(max, leftInfo.max);
		maxSubBSTHead = leftInfo.maxSubBSTHead;
		maxSubBSTSize = leftInfo.maxSubBSTSize;
	}
	if (rightInfo != null) {
		min = Math.min(min, rightInfo.min);
		max = Math.max(max, rightInfo.max);
		if (rightInfo.maxSubBSTSize > maxSubBSTSize) {
			maxSubBSTHead = rightInfo.maxSubBSTHead;
			maxSubBSTSize = rightInfo.maxSubBSTSize;
		}
	}
	if ((leftInfo == null ? true : (leftInfo.maxSubBSTHead == X.left && leftInfo.max < X.value))
			&& (rightInfo == null ? true : (rightInfo.maxSubBSTHead == X.right && rightInfo.min > X.value))) {
		maxSubBSTHead = X;
		maxSubBSTSize = (leftInfo == null ? 0 : leftInfo.maxSubBSTSize)
				+ (rightInfo == null ? 0 : rightInfo.maxSubBSTSize) + 1;
	}
	return new Info(maxSubBSTHead, maxSubBSTSiz e, min, max);
}

// for test
public static Node generateRandomBST(int maxLevel, int maxValue) {
	return generate(1, maxLevel, maxValue);
}

// for test
public static Node generate(int level, int maxLevel, int maxValue) {
	if (level > maxLevel || Math.random() < 0.5) {
		return null;
	}
	Node head = new Node((int) (Math.random() * maxValue));
	head.left = generate(level + 1, maxLevel, maxValue);
	head.right = generate(level + 1, maxLevel, maxValue);
	return head;
}

public static void main(String[] args) {
	int maxLevel = 4;
	int maxValue = 100;
	int testTimes = 1000000;
	for (int i = 0; i < testTimes; i++) {
		Node head = generateRandomBST(maxLevel, maxValue);
		if (maxSubBSTHead1(head) != maxSubBSTHead2(head)) {
			System.out.println("Oops!");
		}
	}
	System.out.println("finish!");
}
}
```



## 序列化与反序列化

![image-20220418170309616](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220418170309616.png)



```java
public class Codec {
  
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {

        if(root == null) return "X,";

        String left = serialize(root.left);
        String right = serialize(root.right);

        return root.val + "," + left + right;

    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {

        String[] nodes = data.split(",");

        Queue<String> queue = new ArrayDeque<>(Arrays.asList(nodes));

        return builder(queue);
    }




    public TreeNode builder(Queue<String> queue) {


        String  node = queue.poll();

        if(node.equals("X")) return null;

        TreeNode root =  new TreeNode(Integer.parseInt(node));

        root.left = builder(queue);
        root.right = builder(queue);


        return root;
    }
}
```











## 二叉树的锯齿形层序遍历





![image-20220427230221528](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220427230221528.png)

使用双端队列

奇数层，左到右

偶数层，右到左



**奇数，从头进头出**

**偶数，从尾进尾出**



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    List<List<Integer>> res = new LinkedList<>(); 

    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root == null)
         return new LinkedList<>();     
     Deque<TreeNode> queue = new ArrayDeque<>();
      int depth = 1;//奇数层开始   
      queue.offer(root); 
     while(!queue.isEmpty()) {
       
      List<Integer> tmp = new LinkedList<>();
      int n = queue.size();

      for(int i = 0; i < n; i++) {

          TreeNode node = (depth % 2) == 0 ? queue.pollLast() : queue.pollFirst();

           tmp.add(node.val);
          if(depth % 2 != 0) {//奇数,从左向右打印，头出
      
            if(node.left != null) {//偶数元素，尾进尾出
                queue.addLast(node.left);
            }
            if(node.right != null) {
                queue.addLast(node.right);
            }

          }else{
           
            if(node.right != null) {
                queue.addFirst(node.right);
            }

            if(node.left != null) {
                queue.addFirst(node.left);
            }
          }
      } 
         res.add(tmp); 
       depth++;
     }
     return res;

    }

}
```



## 完全二叉树最后一个结点



```java
    //返回完全二叉树的最后一个节点
    public TreeNode getLastNode(TreeNode root){
        if(root==null)return root;
        if(root.left==null&&root.right==null)return root;
        int a = getHigh(root.left);
        int b = getHigh(root.right);
        if(a==b){
            //最后一个节点在右子树
            return getLastNode(root.right);
        }else {
            //最后一个节点在左子树
            return getLastNode(root.left);
        }
    }
    //判断二叉树高度
    private int getHigh(TreeNode root){
        TreeNode temp = root;
        int h = 0;
        while (temp!=null){
            h++;
            temp=temp.left;
        }
        return h;
    }
```







## [二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)



![image-20220428123907518](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220428123907518.png)



比较最大编号与所有结点数和是否相等，编号是固定的，结点却不固定。

```java
class Solution {
    int n = 0, p = 0;
    public boolean isCompleteTree(TreeNode root) {
     dfs(root, 1);

     return n == p;
    }
    public void dfs(TreeNode root, int k) {
        //k是传递的值
        if(root == null) return;
        n++;
        //p记录最大编号
        p = Math.max(p, k);
        dfs(root.left, 2 * k);

        dfs(root.right, 2 * k + 1);

    }
}
```





# 贪心算法

**拼接字符串达到最小字典序**



```java
package class09;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;

public class Code01_LowestLexicography {
public static String lowestString1(String[] strs) {
	if (strs == null || strs.length == 0) {
		return "";
	}
	ArrayList<String> all = new ArrayList<>();
	HashSet<Integer> use = new HashSet<>();
	process(strs, use, "", all);
	String lowest = all.get(0);
	for (int i = 1; i < all.size(); i++) {
		if (all.get(i).compareTo(lowest) < 0) {
			lowest = all.get(i);
		}
	}
	return lowest;
}

// strs里放着所有的字符串
// 已经使用过的字符串的下标，在use里登记了，不要再使用了
// 之前使用过的字符串，拼接成了-> path
// 用all收集所有可能的拼接结果
public static void process(String[] strs, 
		HashSet<Integer> use, 
		String path, 
		ArrayList<String> all) {
	if (use.size() == strs.length) {
		all.add(path);
	} else {
		for (int i = 0; i < strs.length; i++) {
			if (!use.contains(i)) {
				use.add(i);
				process(strs, use, path + strs[i], all);
				use.remove(i);
			}
		}
	}
}

public static class MyComparator implements Comparator<String> {
	@Override
	public int compare(String a, String b) {
		return (a + b).compareTo(b + a);
	}
}

public static String lowestString2(String[] strs) {
	if (strs == null || strs.length == 0) {
		return "";
	}
	Arrays.sort(strs, new MyComparator());
	String res = "";
	for (int i = 0; i < strs.length; i++) {
		res += strs[i];
	}
	return res;
}

// for test
public static String generateRandomString(int strLen) {
	char[] ans = new char[(int) (Math.random() * strLen) + 1];
	for (int i = 0; i < ans.length; i++) {
		int value = (int) (Math.random() * 5);
		ans[i] = (char) (97 + value);
	}
	return String.valueOf(ans);
}

// for test
public static String[] generateRandomStringArray(int arrLen, int strLen) {
	String[] ans = new String[(int) (Math.random() * arrLen) + 1];
	for (int i = 0; i < ans.length; i++) {
		ans[i] = generateRandomString(strLen);
	}
	return ans;
}

// for test
public static String[] copyStringArray(String[] arr) {
	String[] ans = new String[arr.length];
	for (int i = 0; i < ans.length; i++) {
		ans[i] = String.valueOf(arr[i]);
	}
	return ans;
}

public static void main(String[] args) {
	int arrLen = 6;
	int strLen = 5;
	int testTimes = 100000;
	for (int i = 0; i < testTimes; i++) {
		String[] arr1 = generateRandomStringArray(arrLen, strLen);
		String[] arr2 = copyStringArray(arr1);
		if (!lowestString1(arr1).equals(lowestString2(arr2))) {
			System.out.println("Oops!");
		}
	}
	System.out.println("finish!");
}
}
```

```java

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String[] strs = new String[n];
        for(int i = 0; i < n; i++) strs[i] = br.readLine();
        Arrays.sort(strs, new Comparator<String>(){
            @Override
            public int compare(String s1, String s2) {
                return (s1 + s2).compareTo(s2 + s1);
            }
        });
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < n; i++) sb.append(strs[i]);
        System.out.println(sb.toString());
    }
}


```



## 会议室

![image-20220417172809519](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220417172809519.png)





```java
package class09;

import java.util.Arrays;
import java.util.Comparator;

public class Code04_BestArrange {
public static class Program {
	public int start;
	public int end;

	public Program(int start, int end) {
		this.start = start;
		this.end = end;
	}
}

public static int bestArrange1(Program[] programs) {
	if (programs == null || programs.length == 0) {
		return 0;
	}
	return process(programs, 0, 0);
}

// 还剩什么会议都放在programs里
// done 之前已经安排了多少会议，数量
// timeLine目前来到的时间点是什么

// 目前来到timeLine的时间点，已经安排了done多的会议，剩下的会议programs可以自由安排
// 返回能安排的最多会议数量
public static int process(Program[] programs, int done, int timeLine) {
	if (programs.length == 0) {
		return done;
	}
	// 还有会议可以选择
	int max = done;
	// 当前安排的会议是什么会，每一个都枚举
	for (int i = 0; i < programs.length; i++) {
		if (programs[i].start >= timeLine) {
			Program[] next = copyButExcept(programs, i);
			max = Math.max(max, process(next, done + 1, programs[i].end));
		}
	}
	return max;
}

public static Program[] copyButExcept(Program[] programs, int i) {
	Program[] ans = new Program[programs.length - 1];
	int index = 0;
	for (int k = 0; k < programs.length; k++) {
		if (k != i) {
			ans[index++] = programs[k];
		}
	}
	return ans;
}

public static int bestArrange2(Program[] programs) {
	Arrays.sort(prog rams, new ProgramComparator());
	int timeLine = 0;
	int result = 0;
	for (int i = 0; i < programs.length; i++) {
		if (timeLine <= programs[i].start) {
			result++;
			timeLine = programs[i].end;
		}
	}
	return result;
}

public static class ProgramComparator implements Comparator<Program> {

	@Override
	public int compare(Program o1, Program o2) {
		return o1.end - o2.end;
	}

}

// for test
public static Program[] generatePrograms(int programSize, int timeMax) {
	Program[] ans = new Program[(int) (Math.random() * (programSize + 1))];
	for (int i = 0; i < ans.length; i++) {
		int r1 = (int) (Math.random() * (timeMax + 1));
		int r2 = (int) (Math.random() * (timeMax + 1));
		if (r1 == r2) {
			ans[i] = new Program(r1, r1 + 1);
		} else {
			ans[i] = new Program(Math.min(r1, r2), Math.max(r1, r2));
		}
	}
	return ans;
}

public static void main(String[] args) {
	int programSize = 12;
	int timeMax = 20;
	int timeTimes = 1000000;
	for (int i = 0; i < timeTimes; i++) {
		Program[] programs = generatePrograms(programSize, timeMax);
		if (bestArrange1(programs) != bestArrange2(programs)) {
			System.out.println("Oops!");
		}
	}
	System.out.println("finish!");
}
}
```





##  会议室 II



给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。



> 示例 1：
>
> 输入：intervals = [[0,30],[5,10],[15,20]]
>
> 输出：2
>
> 示例 2：
>
> 输入：intervals = [[7,10],[2,4]]
>
> 输出：1



```java
// 保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：
// 1. 若目前堆的大小小于K，将当前数字放入堆中。
// 2. 否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；
//    反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0 || arr.length == 0) {
            return new int[0];
        }
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue<Integer> pq = new PriorityQueue<>((v1, v2) -> v2 - v1);
        for (int num: arr) {
            if (pq.size() < k) {
                pq.offer(num);
            } else if (num < pq.peek()) {
                pq.poll();
                pq.offer(num);
            }
        }
        
        // 返回堆中的元素
        int[] res = new int[pq.size()];
        int idx = 0;
        for(int num: pq) {
            res[idx++] = num;
        }
        return res;
    }
}

```







 

![image-20220417195418761](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220417195418761.png)



```java
package class09;

import java.util.HashSet;

public class Code02_Light {
public static int minLight1(String road) {
	if (road == null || road.length() == 0) {
		return 0;
	}
	return process(road.toCharArray(), 0, new HashSet<>());
}

// str[index....]位置，自由选择放灯还是不放灯
// str[0..index-1]位置呢？已经做完决定了，那些放了灯的位置，存在lights里
// 要求选出能照亮所有.的方案，并且在这些有效的方案中，返回最少需要几个灯
public static int process(char[] str, int index, HashSet<Integer> lights) {
	if (index == str.length) { // 结束的时候
		for (int i = 0; i < str.length; i++) {
			if (str[i] != 'X') { // 当前位置是点的话
				if (!lights.contains(i - 1) 
						&& !lights.contains(i) 
						&& !lights.contains(i + 1)) {
					return Integer.MAX_VALUE;
				}
			} 
		}
		return lights.size();
	} else { // str还没结束
		// i   X  . 
		int no = process(str, index + 1, lights);
		int yes = Integer.MAX_VALUE;
		if (str[index] == '.') {
			lights.add(index);
			yes = process(str, index + 1, lights);
			lights.remove(index);
		}
		return Math.min(no, yes);
	}
}

public static int minLight2(String road) {
	char[] str = road.toCharArray();
	int index = 0;
	int light = 0;
	while (index < str.length) {
		if (str[index] == 'X') {
			index++;
		} else { // i -> .
			light++;
			if (index + 1 ==  str.length) {
				break;
			} else {
				if (str[index + 1] == 'X') {
					index = index + 2;
				} else {
					index = index + 3;
				}
			}
		}
	}
	return light;
}

// for test
public static String randomString(int len) {
	char[] res = new char[(int) (Math.random() * len) + 1];
	for (int i = 0; i < res.length; i++) {
		res[i] = Math.random() < 0.5 ? 'X' : '.';
	}
	return String.valueOf(res);
}

public static void main(String[] args) {
	int len = 20;
	int testTime = 100000;
	for (int i = 0; i < testTime; i++) {
		String test = randomString(len);
		int ans1 = minLight1(test);
		int ans2 = minLight2(test);
		if (ans1 != ans2) {
			System.out.println("oops!");
		}
	}
	System.out.println("finish!");
}
 }
```







## 分割的最小代价





![image-20220417212525682](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220417212525682.png)





**哈夫曼树**

```java
package class09;

import java.util.PriorityQueue;

public class Code03_LessMoneySplitGold {
public static int lessMoney1(int[] arr) {
	if (arr == null || arr.length == 0) {
		return 0;
	}
	return process(arr, 0);
}

public static int process(int[] arr, int pre) {
	if (arr.length == 1) {
		return pre;
	}
	int ans = Integer.MAX_VALUE;
	for (int i = 0; i < arr.length; i++) {
		for (int j = i + 1; j < arr.length; j++) {
			ans = Math.min(ans, process(copyAndMergeTwo(arr, i, j), pre + arr[i] + arr[j]));
		}
	}
	return ans;
}

public static int[] copyAndMergeTwo(int[] arr, int i, int j) {
	int[] ans = new int[arr.length - 1];
	int ansi = 0;
	for (int arri = 0; arri < arr.length; arri++) {
		if (arri != i && arri != j) {
			ans[ansi++] = arr[arri];
		}
	}
	ans[ansi] = arr[i] + arr[j];
	return ans;
}
    

public static int lessMoney2(int[] arr) {
	PriorityQueue<Integer> pQ = new PriorityQueue<>();
	for (int i = 0; i < arr.length; i++) {
		pQ.add(arr[i]);
	}
	int sum = 0;
	int cur = 0;
	while (pQ.size() > 1) {
		cur = pQ.poll() + pQ.poll();
		sum += cur;
		pQ.add(cur);
	}
	return sum;
}

    
// for test
public static int[] generateRandomArray(int maxSize, int maxValue) {
	int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
	for (int i = 0; i < arr.length; i++) {
		arr[i] = (int) (Math.random() * (maxValue + 1));
	}
	return arr;
}

public static void main(String[] args) {
	int testTime = 100000;
	int maxSize = 6;
	int maxValue = 1000;
	for (int i = 0; i < testTime; i++) {
		int[] arr = generateRandomArray(maxSize, maxValue);
		if (lessMoney1(arr) != lessMoney2(arr)) {
			System.out.println("Oops!");
		}
	}
	System.out.println("finish!");
}
}
```



## IPO

![image-20220417215802725](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220417215802725.png)

```java
package class09;

import java.util.Comparator;
import java.util.PriorityQueue;

public class Code05_IPO {
public static int findMaximizedCapital(int K, int W, int[] Profits, int[] Capital) {
	PriorityQueue<Program> minCostQ = new PriorityQueue<>(new MinCostComparator());
	PriorityQueue<Program> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
	for (int i = 0; i < Profits.length; i++) {
		minCostQ.add(new Program(Profits[i], Capital[i]));
	}
	for (int i = 0; i < K; i++) {
		while (!minCostQ.isEmpty() && minCostQ.peek().c <= W) {
			maxProfitQ.add(minCostQ.poll());
		}
		if (maxProfitQ.isEmpty()) {
			return W;
		}
		W += maxProfitQ.poll().p;
	}
	return W;
}

public static class Program {
	public int p;
	public int c;

	public Program(int p, int c) {
		this.p = p;
		this.c = c;
	}
}

public static class MinCostComparator implements Comparator<Program> {

	@Override
	public int compare(Program o1, Program o2) {
		return o1.c - o2.c;
	}

}

public static class MaxProfitComparator implements Comparator<Program> {

	@Override
	public int compare(Program o1, Program o2) {
		return o2.p - o1.p;
	}

}
}
```



力扣版本



**用数组和一个大根堆维护**

```java
class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {

      int cur = 0;
    int n = profits.length;
    int[][] arr = new int[n][2];
        
        
for(int i = 0; i < n; i++) {
        arr[i][0] = capital[i];
        arr[i][1] = profits[i];
    }
     Arrays.sort(arr, (a, b) -> a[0] - b[0]);

    PriorityQueue<Integer> queue = new PriorityQueue<>((x,y) -> y - x);

    for(int i = 0; i < k; i++) {

        while(cur < n && arr[cur][0] <= w) {
         //往大根堆加入利润
         queue.add(arr[cur][1]);
         cur++;

        }
        
        if(!queue.isEmpty()) {
            w += queue.poll();
        }else{
           break;
        }
    }
  
    return w;       
}
}
```









# 最短路径



```java
package class10;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;

// no negative weight
public class Code06_Dijkstra {
public static HashMap<Node, Integer> dijkstra1(Node from) {
	// 从head出发到所有点的最小距离
	// key : 从head出发到达key
	// value : 从head出发到达key的最小距离
	// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷
	HashMap<Node, Integer> distanceMap = new HashMap<>();
	distanceMap.put(from, 0);
	// 已经求过距离的节点，存在selectedNodes中，以后再也不碰
	HashSet<Node> selectedNodes = new HashSet<>();
	// from 0
	Node minNode = getMinDistanceAndUnselectedNode(dista`nceMap, selectedNodes);
	while (minNode != null) {
		int distance = distanceMap.get(minNode);
		for (Edge edge : minNode.edges) {
			Node toNode = edge.to;
			if (!distanceMap.containsKey(toNode)) {
				distanceMap.put(toNode, distance + edge.weight);
			} else {
				distanceMap.put(edge.to, 
						Math.min(distanceMap.get(toNode), distance + edge.weight));
			}
		}
		selectedNodes.add(minNode);
		minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
	}
	return distanceMap;
}

public static Node getMinDistanceAndUnselectedNode(
		HashMap<Node, Integer> distanceMap, 
		HashSet<Node> touchedNodes) {
	Node minNode = null;
	int minDistance = Integer.MAX_VALUE;
	for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
		Node node = entry.getKey();
		int distance = entry.getValue();
		if (!touchedNodes.contains(node) && distance < minDistance) {
			minNode = node;
			minDistance = distance;
		}
	}
	return minNode;
}

public static class NodeRecord {
	public Node node;
	public int distance;

	public NodeRecord(Node node, int distance) {
		this.node = node;
		this.distance = distance;
	}
}

public static class NodeHeap {
	private Node[] nodes; // 实际的堆结构
	// key 某一个node， value 上面堆中的位置
	private HashMap<Node, Integer> heapIndexMap;
	// key 某一个节点， value 从源节点出发到该节点的目前最小距离
	private HashMap<Node, Integer> distanceMap;
	private int size; // 堆上有多少个点

	public NodeHeap(int size) {
		nodes = new Node[size];
		heapIndexMap = new HashMap<>();
		distanceMap = new HashMap<>();
		size = 0;
	}

	public boolean isEmpty() {
		return size == 0;
	}

	// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance
	// 判断要不要更新，如果需要的话，就更新
	public void addOrUpdateOrIgnore(Node node, int distance) {
		if (inHeap(node)) {
			distanceMap.put(node, Math.min(distanceMap.get(node), distance));
			insertHeapify(node, heapIndexMap.get(node));
		}
		if (!isEntered(node)) {
			nodes[size] = node;
			heapIndexMap.put(node, size);
			distanceMap.put(node, distance);
			insertHeapify(node, size++);
		}
	}

	public NodeRecord pop() {
		NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
		swap(0, size - 1);
		heapIndexMap.put(nodes[size - 1], -1);
		distanceMap.remove(nodes[size - 1]);
		// free C++同学还要把原本堆顶节点析构，对java同学不必
		nodes[size - 1] = null;
		heapify(0, --size);
		return nodeRecord;
	}

	private void insertHeapify(Node node, int index) {
		while (distanceMap.get(nodes[index]) 
				< distanceMap.get(nodes[(index - 1) / 2])) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	private void heapify(int index, int size) {
		int left = index * 2 + 1;
		while (left < size) {
			int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
					? left + 1
					: left;
			smallest = distanceMap.get(nodes[smallest]) 
					< distanceMap.get(nodes[index]) ? smallest : index;
			if (smallest == index) {
				break;
			}
			swap(smallest, index);
			index = smallest;
			left = index * 2 + 1;
		}
	}

	private boolean isEntered(Node node) {
		return heapIndexMap.containsKey(node);
	}

	private boolean inHeap(Node node) {
		return isEntered(node) && heapIndexMap.get(node) != -1;
	}

	private void swap(int index1, int index2) {
		heapIndexMap.put(nodes[index1], index2);
		heapIndexMap.put(nodes[index2], index1);
		Node tmp = nodes[index1];
		nodes[index1] = nodes[index2];
		nodes[index2] = tmp;
	}
}

// 改进后的dijkstra算法
// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回
public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
	NodeHeap nodeHeap = new NodeHeap(size);
	nodeHeap.addOrUpdateOrIgnore(head, 0);
	HashMap<Node, Integer> result = new HashMap<>();
	while (!nodeHeap.isEmpty()) {
		NodeRecord record = nodeHeap.pop();
		Node cur = record.node;
		int distance = record.distance;
		for (Edge edge : cur.edges) {
			nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
		}
		result.put(cur, distance);
	}
	return result;
}
}
```



# 动态规划



## 第一种模型（从左往右）



 ![image-20220418204834205](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220418204834205.png)



  

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] f = new int[n + 10];
        f[0] = 1;
        for(int i = 1; i <= n;i ++)
        {
            if(s.charAt(i - 1) != '0') f[i] = f[i - 1]; //单独解码s[i - 1]
            if(i >= 2)
            {
                int t = (s.charAt(i - 2) - '0') * 10 + s.charAt(i - 1) - '0';
                if(t >= 10 && t <= 26) f[i] += f[i - 2]; //将s[i - 2] 和 s[i - 1]组合解码
            }
        }
        return f[n];
    }
}

```



- 第一种情况

  f[i]=f[i−1]

  

- 第二种情况

  f[i]=f[i−1]+f[i−2]



## 背包问题

![image-20220419171837690](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220419171837690.png)

**java**

```java
package class11;

public class Code07_Knapsack {

	public static int getMaxValue(int[] w, int[] v, int bag) {
		return process(w, v, 0, 0, bag);
	}

	// 不变 ： w[]  v[]  bag
	// index... 最大价值
	// 0..index-1上做了货物的选择，使得你已经达到的重量是多少alreadyW
	// 如果返回-1，认为没有方案
	// 如果不返回-1，认为返回的值是真实价值
	public static int process(int[] w, int[] v, int index, int alreadyW, int bag) {
		if (alreadyW > bag) {
			return -1;
		}
		// 重量没超
		if (index == w.length) {
			return 0;
		}
		int p1 = process(w, v, index + 1, alreadyW, bag);
		int p2next = process(w, v, index + 1, alreadyW + w[index], bag);
		int p2 = -1;
		if (p2next != -1) {
			p2 = v[index] + p2next;
		}
		return Math.max(p1, p2);

	}

	public static int maxValue(int[] w, int[] v, int bag) {
		return process(w, v, 0, bag);
	}

	// 只剩下rest的空间了，
	// index...货物自由选择，但是剩余空间不要小于0
	// 返回 index...货物能够获得的最大价值
	public static int process(int[] w, int[] v, int index, int rest) {
		if (rest < 0) { // base case 1
			return -1;
		}
		// rest >=0
		if (index == w.length) { // base case 2
			return 0;
		}
		// 有货也有空间
		int p1 = process(w, v, index + 1, rest);
		int p2 = -1;
		int p2Next = process(w, v, index + 1, rest - w[index]);
		if(p2Next!=-1) {
			p2 = v[index] + p2Next;
		}
		return Math.max(p1, p2);
	}

	public static int dpWay(int[] w, int[] v, int bag) {
		int N = w.length;
		int[][] dp = new int[N + 1][bag + 1];
		for (int index = N - 1; index >= 0; index--) {
			for (int rest = 1; rest <= bag; rest++) {
				dp[index][rest] = dp[index + 1][rest];
				if (rest >= w[index]) {
					dp[index][rest] = Math.max(dp[index][rest], v[index] +  dp[index + 1][rest - w[index]]);
				}
			}
		}
		return dp[0][bag];
	}  

	public static void main(String[] args) {
		int[] weights = { 3, 2, 4, 7 };
		int[] values = { 5, 6, 3, 19 };
		int bag = 11;
		System.out.println(maxValue(weights, values, bag));
		System.out.println(dpWay(weights, values, bag));
	}

}

```





```c++
#include<iostream>
using namespace std;
int v[1010], w[1010]; 
int f[1010][1010]; 

auto main() -> int
{
    ios::sync_with_stdio(false);
    int N, V; cin >> N >> V;          // N件物品, 背包最大容量为V
    for(int i = 1; i <= N; ++i) cin >> v[i] >> w[i];   // 输入第 i 件物品的体积 和 价值 (体积为整数 > 0)
    
    for(int i = 1; i <= N; ++i)       // 先枚举物品
        for(int j = 0; j <= V; ++j)   // 再枚举体积  体积从0 开始，然后 ++, 最大不超过V 
        {
            f[i][j] = f[i - 1][j];                    
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
    cout << f[N][V] << endl;    // 最后输出我们的方案, 即从1 ~ N种物品种选, 所选物品体积不超过V的最大价值
    return 0;
}

处。
```



### 01背包问题



#### 模板(二维)

数组初始化



```java
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagsize = 4;
        testweightbagproblem(weight, value, bagsize);
    }

    public static void testweightbagproblem(int[] weight, int[] value, int bagsize){
        int wlen = weight.length, value0 = 0;
        //定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值
        int[][] dp = new int[wlen + 1][bagsize + 1];
        //初始化：背包容量为0时，能获得的价值都为0
        for (int i = 0; i <= wlen; i++){
            dp[i][0] = value0;
        }
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 1; i <= wlen; i++){//从第一个物品
            for (int j = 1; j <= bagsize; j++){
                if (j < weight[i - 1]){//不选择当前物品（因为当前背包容量小于当前物品重量）
                    dp[i][j] = dp[i - 1][j];
                }else{//选择当前物品（当前物品价值加上+（要的值减去当前物品价值的dp）），并和不取物品值比较取最大
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
                }
                        
                    dp[i][j] = dp[i - 1][j];
                if(j >= nums[i - 1]){//选择当前物品（当前物品价值加上+（要的值减去当前物品价值的dp）），并和不取物品值比较取最大
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
                }
                
                
            }
        }
        
        return dp[weight.length][b]
        //打印dp数组
        for (int i = 0; i <= wlen; i++){
            for (int j = 0; j <= bagsize; j++){
                System.out.print(dp[i][j] + " ");
            }
            System.out.print("\n");
        }
    }
```



#### 模板(一维)



```java
   public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagsize = 4;
        testweightbagproblem(weight, value, bagsize);
    }

    public static void testweightbagproblem(int[] weight, int[] value, int bagsize){
        int wlen = weight.length, value0 = 0;
        //定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值
        int[][] dp = new int[wlen + 1][bagsize + 1];
        //初始化：背包容量为0时，能获得的价值都为0
        for (int i = 0; i <= wlen; i++){
            dp[i][0] = value0;
        }
        //遍历顺序：先遍历物品，再遍历背包容量
        for (int i = 1; i <= wlen; i++){
            for (int j = 1; j <= bagsize; j++){
                if (j < weight[i - 1]){
                    dp[i][j] = dp[i - 1][j];
                }else{
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);
                }
            }
        }
        //打印dp数组
        for (int i = 0; i <= wlen; i++){
            for (int j = 0; j <= bagsize; j++){
                System.out.print(dp[i][j] + " ");
            }
            System.out.print("\n");
        }
    }
```















#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)



![image-20220420205031541](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220420205031541.png)



```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {




      int sum = 0;
      for(int i = 0; i < nums.length; i++) {
          sum += nums[i];
      }

      if((target + sum) % 2 != 0) return 0;
      int size = (target + sum) / 2;
      if(size < 0)  size = -size;

      int[] dp = new int[size + 1];

      dp[0] = 1;

      for(int i = 0; i < nums.length; i++) {

          for(int j = size; j >= nums[i]; j--) {
              dp[j] += dp[j - nums[i]];
          }
      }
       
    return dp[size];


    }
}
```



#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

![image-20220420221741824](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220420221741824.png)

```java
public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        // 题目已经说非空数组，可以不做非空判断
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        // 特判：如果是奇数，就不符合要求
        if ((sum & 1) == 1) {
            return false;
        }

        int target = sum / 2;
        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        boolean[][] dp = new boolean[len][target + 1];

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }
        // 再填表格后面几行
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        return dp[len - 1][target];
    }
}


```



### 完全背包问题









#### 零钱兑换Ⅰ



![image-20220419223515379](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220419223515379.png)







```java
class Solution {
    public int coinChange(int[] coins, int amount) {

        //自底向上的动态规划

        if(coins.length == 0) {
            return -1;
        }

        int[] memo = new int[amount + 1];
        memo[0] = 0;

        for(int i = 1; i <= amount; i++) {
             int min = Integer.MAX_VALUE;
            for(int j = 0; j < coins.length; j++) {
                if(i - coins[j] >= 0 && memo[i - coins[j]] < min) {
                    min = memo[i - coins[j]] + 1;
                }
            }

            memo[i] = min;
        }
        return memo[amount] ==  Integer.MAX_VALUE ? -1 : memo[amount];
    }
}
```









二维比较好理解一些

```java
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        int f[n + 1][amount + 1]; memset(f, 0x3f, sizeof f);

        for (int i = 0; i <= n; i ++ ) f[i][0] = 0;
        
        for (int i = 1; i <= n; i ++ )                                   // 遍历物品
            for (int j = 1; j <= amount; j ++ )                          // 遍历包的体积
            {
                f[i][j] = f[i - 1][j];
                if (j >= coins[i - 1])
                    f[i][j] = min(f[i][j], f[i][j - coins[i - 1]] + 1);  // 将K种状态简化到上述2种状态
            }
        return f[n][amount] == 0x3f3f3f3f ? -1 : f[n][amount];
    }
};


```







#### 零钱兑换Ⅱ

![image-20220421162128113](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220421162128113.png)







```java
class Solution {
    public int change(int cnt, int[] cs) {
        int n = cs.length;
        int[][] f = new int[n + 1][cnt + 1];
        f[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int val = cs[i - 1];
            for (int j = 0; j <= cnt; j++) {
                f[i][j] = f[i - 1][j];
                for (int k = 1; k * val <= j; k++) {
                    f[i][j] += f[i - 1][j - k * val];  
                }
            }
        }
        return f[n][cnt];
    }
}



```



![image-20220421162644500](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220421162644500.png)

















## 第二种模型（范围上尝试的模型）



### 博弈论

![image-20220419173531265](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220419173531265.png)

```java
package class11;

public class Code08_CardsInLine {

	public static int win1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		return Math.max(
				f(arr, 0, arr.length - 1),
				s(arr, 0, arr.length - 1)
				);
	}

	// L....R
	// F  S  L+1..R
	         // L..R-1
    //先手
	public static int f(int[] arr, int L, int R) {
		if (L == R) {
			return arr[L];
		}
		
		return Math.max( 
				arr[L] + s(arr, L + 1, R),
				arr[R] + s(arr, L, R - 1)
				);
	}

    //后手
	// arr[L..R]
	public static int s(int[] arr, int L, int R) {
		if (L == R) {
			return 0;
		}
		return Math.min(
				f(arr, L + 1, R), // arr[i]
				f(arr, L, R - 1)  // arr[j]
				); 
	}

	public static int win2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int N = arr.length;
		int[][] f = new int[N][N];
		int[][] s = new int[N][N];
		for(int i = 0; i < N;i++) {
			f[i][i] = arr[i];
		}
		// s[i][i] = 0;
		for(int i = 1; i < N;i++) {
			int L =0;
			int R =i;
			while(L < N && R < N) {
				
				f[L][R] = Math.max(
						arr[L] + s[L + 1][ R],
						arr[R] + s[L][R - 1]
						); 
				s[L][R] = Math.min(
						f[L + 1][R], // arr[i]
						f[L][R - 1]  // arr[j]
						); 
				
				L++;
				R++;
				
			}
		}
		return Math.max(f[0][N-1], s[0][N-1]);
	}

	public static void main(String[] args) {
		int[] arr = { 4,7,9,5,19,29,80,4 };
		// A 4 9
		// B 7 5
		System.out.println(win1(arr));
		System.out.println(win2(arr));

	}

}
```



**问题描述:五个海盗打算瓜分抢来的100个金币，按抽签的顺序依次提出分金方案，首先，由一号提出一种分金方案，但是需要超过半数人同意才能被通过，否则一号会被投到 大海喂鲨鱼，依次类推...假设每个海盗足够聪明，保证自己所获的效益最大化，问：分金的方案如何？**





###   N皇后1·

```java
package class11;

public class Code09_NQueens {

	public static int num1(int n) {
		if (n < 1) {
			return 0;
		}
		// record[0] ?  record[1]  ?  record[2]
		int[] record = new int[n]; // record[i] -> i行的皇后，放在了第几列
		return process1(0, record, n);
	}

	// 潜台词：record[0..i-1]的皇后，任何两个皇后一定都不共行、不共列，不共斜线
	// 目前来到了第i行
	// record[0..i-1]表示之前的行，放了的皇后位置
	// n代表整体一共有多少行  0~n-1行
	// 返回值是，摆完所有的皇后，合理的摆法有多少种
	public static int process1(int i, int[] record, int n) {
		if (i == n) { // 终止行
			return 1;
		}
		// 没有到终止位置，还有皇后要摆
		int res = 0;
		for (int j = 0; j < n; j++) { // 当前行在i行，尝试i行所有的列  -> j
			// 当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线，
			// 如果是，认为有效
			// 如果不是，认为无效
			if (isValid(record, i, j)) {
				record[i] = j;
				res += process1(i + 1, record, n);
			}
		}
		return res;
	}

	// record[0..i-1]你需要看，record[i...]不需要看
	// 返回i行皇后，放在了j列，是否有效
	public static boolean isValid(int[] record, int i, int j) {
		for (int k = 0; k < i; k++) { // 之前的某个k行的皇后	
			// k, record[k]   i, j
			if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {
				return false;
			}
		}
		return true;
	}

	// 请不要超过32皇后问题
	public static int num2(int n) {
		if (n < 1 || n > 32) {
			return 0;
		}
		// 如果你是13皇后问题，limit 最右13个1，其他都是0
		int limit = n == 32 ? -1 : (1 << n) - 1;
		return process2(limit, 0, 0, 0);
	}

	// limit 划定了问题的规模 -> 固定
	
	// colLim 列的限制，1的位置不能放皇后，0的位置可以
	// leftDiaLim 左斜线的限制，1的位置不能放皇后，0的位置可以
	// rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以
	public static int process2(
			int limit, 
			int colLim, 
			int leftDiaLim,
			int rightDiaLim) {
		if (colLim == limit) { // base case
			return 1;
		}
		// 所有可以放皇后的位置，都在pos上
		// colLim | leftDiaLim | rightDiaLim   -> 总限制
		// ~ (colLim | leftDiaLim | rightDiaLim) -> 左侧的一坨0干扰，右侧每个1，可尝试
		int pos = limit & ( ~(colLim | leftDiaLim | rightDiaLim) );
		int mostRightOne = 0;
		int res = 0;
		while (pos != 0) {
			// 其取出pos中，最右侧的1来，剩下位置都是0
			mostRightOne = pos & (~pos + 1);
			pos = pos - mostRightOne;
			res += process2(limit, 
					colLim | mostRightOne,
					(leftDiaLim | mostRightOne) << 1,
					(rightDiaLim | mostRightOne) >>> 1);
		}
		return res;
	}

	public static void main(String[] args) {
		int n = 15;

		long start = System.currentTimeMillis();
		System.out.println(num2(n));
		long end = System.currentTimeMillis();
		System.out.println("cost time: " + (end - start) + "ms");

		start = System.currentTimeMillis();
		System.out.println(num1(n));
		end = System.currentTimeMillis();
		System.out.println("cost time: " + (end - start) + "ms");

	}
}

```



 





# topK问题



## [ 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)





![image-20220420163643438](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220420163643438.png)







**经典topk问题**



### 快排(O(NlogN))

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {

        int from = 0, to = nums.length - 1;
         while(true) {
                int x = partion(nums, from, to);
                if(x == k - 1) return nums[x];
                else if(x > k -1 ) to = x - 1; 
                else from = x + 1; 
             
         }         
    }

    public int partion(int[] nums, int from, int to) {

      int left = from, right = to;
    

        while(left < right) {
            
            while(left < right && nums[right] <= nums[from]) {
                right--;
            }
            while(left < right && nums[left] >= nums[from]){
                left++;
            }
            if(left < right) 
            swap(nums,left,right);
        }

          swap(nums,from, left);

        return left;

    }


    public void swap(int[] nums, int p, int q) {
        int temp = nums[p];
        nums[p] = nums[q];
        nums[q] = temp;
    }


}
```



### 堆(O(NlogK))

由于是topk最大，所有维护最小堆



```java
class Solution {
    public int findKthLargest(int[] nums, int k) {

        PriorityQueue<Integer> pq = new PriorityQueue<>(k);
     
       for(int num : nums) {
          if(pq.size() < k) {
              pq.add(num);
          }else{
            if(pq.peek() < num) {
                pq.poll();
                pq.add(num);
            }
          }
          
       }

       return pq.peek();


    }
}
```



前面两种时间复杂度基本都是O(NlogN);





**下面这种解法可以使，复杂度到O(N)**

### BFPTR



在BFPTR算法中，仅仅是改变了快速排序**Partion**中的**pivot**值的选取，在快速排序中，我们始终选择第一个元素或者最后一个元素作为**pivot**，而在BFPTR算法中，**每次选择五分中位数的中位数**作为**pivot**，这样做的目的就是使得划分比较合理，从而避免了最坏情况的发生。算法步骤如下





```java
// 利用bfprt算法，时间复杂度O(N)
public static int minKth3(int[] array, int k) {
   int[] arr = copyArray(array);
   return bfprt(arr, 0, arr.length - 1, k - 1);
}

// arr[L..R]  如果排序的话，位于index位置的数，是什么，返回
public static int bfprt(int[] arr, int L, int R, int index) {
   if (L == R) {
      return arr[L];
   }
   int pivot = medianOfMedians(arr, L, R);
   int[] range = partition(arr, L, R, pivot);
   if (index >= range[0] && index <= range[1]) {
      return arr[index];
   } else if (index < range[0]) {
      return bfprt(arr, L, range[0] - 1, index);
   } else {
      return bfprt(arr, range[1] + 1, R, index);
   }
}

// arr[L...R]  五个数一组
// 每个小组内部排序
// 每个小组中位数领出来，组成marr
// marr中的中位数，返回
public static int medianOfMedians(int[] arr, int L, int R) {
   int size = R - L + 1;
   int offset = size % 5 == 0 ? 0 : 1;
   int[] mArr = new int[size / 5 + offset];
   for (int team = 0; team < mArr.length; team++) {
      int teamFirst = L + team * 5;
      // L ... L + 4
      // L +5 ... L +9
      // L +10....L+14
      mArr[team] = getMedian(arr, teamFirst, Math.min(R, teamFirst + 4));//每个组的中位数组成的数组
   }
   // marr中，找到中位数
   // marr(0, marr.len - 1,  mArr.length / 2 )
   return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);//中位数的数组，递归bfprt
}

public static int getMedian(int[] arr, int L, int R) {
   insertionSort(arr, L, R);
   return arr[(L + R) / 2];
}

public static void insertionSort(int[] arr, int L, int R) {//插入排序
   for (int i = L + 1; i <= R; i++) {
      for (int j = i - 1; j >= L && arr[j] > arr[j + 1]; j--) {
         swap(arr, j, j + 1);
      }
   }
}
public static void swap(int[] arr, int i1, int i2) {
        int tmp = arr[i1];
        arr[i1] = arr[i2];
        arr[i2] = tmp;
}
```





### 快排改进



```java
class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int targetIndex = len - k;
        int low = 0, high = len - 1;
        while (true) {
            int i = partition(nums, low, high);
            if (i == targetIndex) {
                return nums[i];
            } else if (i < targetIndex) {
                low = i + 1;
            } else {
                high = i - 1;
            }
        }
    }

    /**
     * 分区函数，将 arr[high] 作为 pivot 分区点
     * i、j 两个指针，i 作为标记“已处理区间”和“未处理区间”的分界点，也即 i 左边的（low~i-1）都是“已处理区”。
     * j 指针遍历数组，当 arr[j] 小于 pivot 时，就把 arr[j] 放到“已处理区间”的尾部，也即是 arr[i] 所在位置
     * 因此 swap(arr, i, j) 然后 i 指针后移，i++
     * 直到 j 遍历到数组末尾 arr[high]，将 arr[i] 和 arr[high]（pivot点） 进行交换，返回下标 i，就是分区点的下标。
     */
    private int partition(int[] arr, int low, int high) {
        int i = low;
        int pivot = arr[high];
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                swap(arr, i, j);
                i++;
            }
        }
        swap(arr, i, high);
        return i;
    }

    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

```















# KMP

## [重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

![image-20220424165935010](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220424165935010.png)

## 求next数组



```java
public int[] getNext(String s){
    int i = 0;
    int j = -1;
    int n = s.length();
    
    int[] next = new int[n];
    next[0] = -1;

    while(i < n - 1){
        if(j == -1 || s.charAt(i) == s.charAt(j)){
            i += 1;
            j += 1;
            next[i] = j;
        }else{
            j = next[j];
        }
    }
    return next;
}
```







**解法**

```java
class Solution {
     //kmp求next数组
     public int[] getNext(String s) {
         int i = 0;
         int j = -1;
         
         int n = s.length();

         int[] next = new int[s.length()];
         next[0] = -1;
         while(i < n - 1) {
             if(j == -1 || s.charAt(i) == s.charAt(j)) {
                 i++;
                 j++;
                 next[i] = j;
             }else{
                 j = next[j];
             }
         }
         return next;

     }
   
    public boolean repeatedSubstringPattern(String s) {
           if(s.length() == 0) return false;
           int n = s.length();
           int[] next = getNext(s);
           int len = next[s.length() - 1] + 1;
           
           if(len == 0 || s.charAt(n - 1) != s.charAt(n - 1 - len)) return false;

            return  n % (n - len) == 0;

    }


}
```





























![image-20220425110908601](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220425110908601.png)



```python
def solve(A,x):
    def find(p):
        for i in sorted(A):
            if i>=p:
                return tmp
            tmp = i
        return tmp
    _x = list(map(int,str(x)))
    def helper(s): 
        if s >= len(_x)-1:
            if _x[s]<=min(A):
                return False, str(max(A))
            else:
                return True, str(find(_x[s]))
        cur = _x[s]
        ans = helper(s+1)
        if not ans[0]:
            if cur <= min(A):
                return False, str(max(A))*(len(_x)-s)
            else:
                return True, str(find(cur))+str(max(A))*(len(_x)-s-1)
        else:
            if cur < min(A):
                return False, str(max(A))*(len(_x)-s)
            elif cur in A:
                return True, str(cur)+ans[-1]
            else:
                return True, str(find(cur))+str(max(A))*(len(_x)-s-1)
    ans = helper(0) 
    if ans[0]:
        return int(ans[-1])
    else:
        res = ans[-1][1::]
        if not res:
            return -1
        return int(res)
print(solve([1, 2, 4, 9], 2533))
print(solve([1, 2, 4, 9], 2409))
print(solve([1, 2, 4, 9], 4921))
print(solve([1, 2, 4, 9], 2100))
print(solve([1, 2, 4, 9], 1))
```















# 递归加回溯

## 重构数字

![image-20220426175036780](../../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220426175036780.png)





### 冒泡排序（比较好理解）

```java
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    sort(s1.begin(), s1.end());  // 一定记得先排序！

    if (s1.size() < s2.size()) {  
        //如果s1的位数比s2小，那么直接输出s1的最大值即可。
        reverse(s1.begin(), s1.end());
        cout << s1 << endl;
    }
    else {
        // 由于一定存在答案，所以s1.size() == s2.size()
        // 冒泡排序
        int n = s1.size();
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                string tmp = s1;
                swap(tmp[i], tmp[j]);  
                if (tmp >= s1 && tmp <= s2) {
                    // 尝试交换相邻元素
                    // 如果交换的结果能使s1变大，并且不大于s2，那就允许此次交换
                    s1 = tmp;
                }
            }
        }
        cout << s1 << endl;
    }
    return 0;
}

```



### dfs(难理解)



```java
#include <bits/stdc++.h>
using namespace std;
#define int long long

unordered_map<char, int> st;
string res = "";

void dfs(string& s1, string& s2, string& path, int u, bool flag) {
    if (u == s2.size()) {
        if (res == "") res = path;
        return;
    }
    char start;
    if (flag) start = '9';
    else start = s2[u];
    for (int i = start; i >= '0'; i--) {
        if (st[i]) {
            st[i]--;
            path += i;
            if (i < s2[u]) flag = true;
            if (res == "") dfs(s1, s2, path, u + 1, flag);
            path.pop_back();
            st[i]++;
        }
    }

}

void solve() {
    string s1, s2;
    cin >> s1 >> s2;
    sort(s1.begin(), s1.end(), [](char a, char b) { return a > b; });
    if (s1.size() < s2.size()) {
        cout << s1 << endl;
        return;
    }
    for (auto c : s1) st[c]++;

    for (int i = s2[0]; i >= '0'; i--) {
        if (st[i]) {
            st[i]--;
            string path;
            path += i;
            bool flag = false;
            if (i < s2[0]) flag = true;
            if (res == "") dfs(s1, s2, path, 1, flag);
            path.pop_back();
            st[i]++;
        }
    }
    cout << res << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    solve();

    return 0;
}


```





### python

```python
def solve(A,x):
    def find(p):
        for i in sorted(A):
            if i>=p:
                return tmp
            tmp = i
        return tmp
    _x = list(map(int,str(x)))
    def helper(s): 
        if s >= len(_x)-1:
            if _x[s]<=min(A):
                return False, str(max(A))
            else:
                return True, str(find(_x[s]))
        cur = _x[s]
        ans = helper(s+1)
        if not ans[0]:
            if cur <= min(A):
                return False, str(max(A))*(len(_x)-s)
            else:
                return True, str(find(cur))+str(max(A))*(len(_x)-s-1)
        else:
            if cur < min(A):
                return False, str(max(A))*(len(_x)-s)
            elif cur in A:
                return True, str(cur)+ans[-1]
            else:
                return True, str(find(cur))+str(max(A))*(len(_x)-s-1)
    ans = helper(0) 
    if ans[0]:
        return int(ans[-1])
    else:
        res = ans[-1][1::]
        if not res:
            return -1
        return int(res)
print(solve([1, 2, 4, 9], 2533))
print(solve([1, 2, 4, 9], 2409))
print(solve([1, 2, 4, 9], 4921))
print(solve([1, 2, 4, 9], 2100))
print(solve([1, 2, 4, 9], 1))
```





####  





















# 图

## 判断图中是否有环



**拓扑排序**

有相同

1. 求出图中所有结点的度。
2. 将所有入度 = 0 的结点入队。（独立结点的度为 0）
3. 当队列不空时，弹出队首元素，把与队首元素相邻节点的度减一。如果相邻节点的度变为0，则将相邻结点入队。
4. 循环结束时判断已经访问的结点数是否等于 n。等于 n 说明全部结点都被访问过，无环；反之，则有环。



# LRU

```java
public class LRUCache {
    Entry head, tail;
    int capacity;
    int size;
    Map<Integer, Entry> cache;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        // 初始化链表
        initLinkedList();
        size = 0;
        cache = new HashMap<>(capacity + 2);
    }

    /**
     * 如果节点不存在，返回 -1.如果存在，将节点移动到头结点，并返回节点的数据。
     */
    public int get(int key) {
        Entry node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 存在移动节点
        moveToHead(node);
        return node.value;
    }

    /**
     * 将节点加入到头结点，如果容量已满，将会删除尾结点
     */
    public void put(int key, int value) {
        Entry node = cache.get(key);
        if (node != null) {
            node.value = value;
            moveToHead(node);
            return;
        }
        // 不存在。先加进去，再移除尾结点
        // 此时容量已满 删除尾结点
        if (size == capacity) {
            Entry lastNode = tail.pre;
            deleteNode(lastNode);
            cache.remove(lastNode.key);
            size--;
        }
        // 加入头结点
        Entry newNode = new Entry();
        newNode.key = key;
        newNode.value = value;
        addNode(newNode);
        cache.put(key, newNode);
        size++;
    }

    private void moveToHead(Entry node) {
        // 首先删除原来节点的关系
        deleteNode(node);
        addNode(node);
    }

    private void addNode(Entry node) {
        head.next.pre = node;
        node.next = head.next;

        node.pre = head;
        head.next = node;
    }

    private void deleteNode(Entry node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    public static class Entry {
        public Entry pre;
        public Entry next;
        public int key;
        public int value;

        public Entry(int key, int value) {
            this.key = key;
            this.value = value;
        }

        public Entry() {
        }
    }

    private void initLinkedList() {
        head = new Entry();
        tail = new Entry();

        head.next = tail;
        tail.pre = head;
    }

    public static void main(String[] args) {
        LRUCache cache = new LRUCache(2);
        cache.put(1, 1);
        cache.put(2, 2);
        System.out.println(cache.get(1));
        cache.put(3, 3);
        System.out.println(cache.get(2));
    }
}

```



# 待完善。。。。。





















































































































































































































































































































































































