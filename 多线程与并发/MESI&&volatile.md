---
title: MESI&&volatile
categories:
  - 多线程与并发
tags:
  - MESI&&volatile
abbrlink: 56288
date: 2022-04-9 19:34:20
---





# CPU三级缓存架构（硬件）

先讲讲CPU三级缓存架构

![image-20220409222559078](../../images/MESI&&volatile/image-20220409222559078.png)

- 存储器存储空间大小：内存 > L3 > L2 > L1 > 寄存器
- 存储器速度快慢排序：寄存器 > L1 > L2 > L3 > 内存

cpu与内存的交互之间还隔着三级缓存





## **CPU为何要有高速缓存**

CPU在摩尔定律的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以解决I\O速度和CPU运算速度之间的不匹配问题。

在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理。

**时间局部性（Temporal Locality）**：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。

比如循环、递归、方法的反复调用等。

**空间局部性（Spatial Locality）**：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。

比如顺序执行的代码、连续创建的两个对象、数组等。







## **带有高速缓存的CPU执行计算的流程**

1. 程序以及数据被加载到主内存
2. 指令和数据被加载到CPU的高速缓存
3. CPU执行指令，把结果写到高速缓存
4. 高速缓存中的数据写回主内存





## 缓存行

从内存读取数据的时候，会把这个数据所在的那一行读进去，它和它周围的称为缓存行（大小为64字节），

![image-20220409222651513](../../images/MESI&&volatile/image-20220409222651513.png)

## 伪共享问题

**查看jmm文章**





# volatile

volatile关键字

先看例子

```java
public class Test01 {
   private  static volatile boolean  initFlag = false;
  //  private static boolean  initFlag = false;

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("waiting data");
                while (!initFlag){

                }
                System.out.println("success");
            }
        }).start();

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("准备数据");
                    initFlag = true;
                System.out.println("准备数据完成");
            }
        }).start();
    }
}
```

在没加volatile之前，第一个线程while循环是不会结束的，读取的m一直是false（即便第二个线程改了m为true）,而在加了volatile之后，第一个线程读取m终于为true.;

没加volatile之前为什么会出现这种情况，因为JMM模型里面，我们的线程操作的是工作内存（主内存的副本）里面的数据，而不同线程之间的工作内存数据相互是看不到的。

那我们加了volatile之后（这个是基于缓存一致性协议的）

- 当写一个volatile变量时，JMM会把该线程自己的工作内存中的共享变量的值刷新到主内存
- 当读一个volatile变量时，JMM会把该线程自己的工作内存置为无效，保证能在主内存中读到最新数据（这个基于总线嗅探机制）



**volatile与并发三大特性**

- **原子性** ： volatile不保证原子性
- **有序性**： 基于内存屏障，（另一篇博客有讲解法）[https://dgw_521.gitee.io/2022/04/09/jmm/jmm/]
- **可见性**:  基于MESI下文有详解 





# MESI(缓存一致性协议)

首先，为什么写这个MESI，**因为这是volatile保障可见性的底层原理。**



MESI是缓存一致性协议的一种实现。

大家都知道，被volatile修饰的变量，能在多个线程操作同一变量时，保证各个线程之间对这个变量的可见性，那底层是怎样实现的呢？

 

被vilatile修饰的变量解释成字节码后，会有个lock前缀，这个lock前缀会触发缓存一致性协议，下面看看这个MESI是怎样工作的。



**MESI协议缓存状态**

MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：

**缓存行（Cache line）**:缓存存储数据的单元。

| 状态                     | 描述                                                         |                                                     监听任务 |
| ------------------------ | ------------------------------------------------------------ | -----------------------------------------------------------: |
| M 修改 (Modified)        | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 | 缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。 |
| E 独享、互斥 (Exclusive) | 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 | 缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。 |
| S 共享 (Shared)          | 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 | 缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。 |
| I 无效 (Invalid)         | 该Cache line无效。                                           |                                                           无 |



**注意：**

**对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的**。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。

从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。





## 具体工作流程

![image-20220409225434877](../../images/MESI&&volatile/image-20220409225434877.png)

当cpu0通过总线去内存读x变量的时候，发现读取它被lock前缀修饰了，这个变量通过总线的时候就会被其他cpu监听到，当这个变量读进l3缓存的时候，发现这个变量没有被其他cpu读取，那么这个变量副本就标记为E状态（独占），如果另一个cpu1也读取了这个变量，将这个变量复制到了l3缓存里面，那么过刚才那个cpu0就监听到了，改变它之前读的副本状态为S状态（代表几个cpu读了这个变量）。



如果这两个cpu都要修改这个变量怎么办，各自对这个变量所在的缓存行进行加锁，哪个加锁成功了就可以进行修改，在加锁的时候同时对总线发要进行本地写的消息，加锁的消息发送成功后，被另外一个拥有同样变量副本的cpu捕捉后会放弃自己对缓存行的加锁操作（有人在加锁了），然后标记变量副本为I状态（无效状态）



如果两个cpu，例如cpu0和cpu1同时对自己的缓存行加锁时候怎么办，这个时候就通过总线裁决来判断哪个加锁有效。



假如这时候cpu1写成功了，数据刷回去了，另一个写失败的会重新读取变量到缓存里面。



**为什么其他线程修改了本地的变量然后刷回主存，其他线程能及时得到最新值呢，因为其他线程的缓存数据都失效了。**







![image-20220409224605808](../../images/MESI&&volatile/image-20220409224605808.png)





 









# **volatile**缓存可见性实现原理（总结）

![image-20220211225439967](../../images/MESI&&volatile/image-20220211225439967.png)



- **总结一句话：被volatile修饰的变量，代码编译成字节码后，字节码再转变为汇编后，对应汇编指令变量前面会加上lock前缀，在汇编层面会锁主这个变量所在的缓存，并将当前缓存行的数据立即写回系统内存（主内存）、**
- **这个写回内存的操作会引起其他cpu缓存了该内存地址的数据无效（这个是根据MESI协议里面的总线嗅探机制）**
- **所以，某个线程修改了数据，其他线程能立即拿到修改后的数据，保证了可见性。**



**lock并不是一种内存屏障，但是能提供内存屏障的功能。**













## 可见性原理

volatile关键字修饰的变量会存在一个“lock:”的前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。**Lock会对CPU总线或高速缓存加锁（一般只是对缓存行加锁），可以理解为CPU指令级的一种锁。**





在具体的执行上，它先对总线或缓存加锁，然后执行后面的指令，**在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放**。**最后释放锁后会把高速缓存中的脏数据（修改过的数据）全部刷新回主内存**，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效（根据总线嗅探机制）。



这样其他线程要想继续访问该变量就得重新从主内存加载





















# **volatile的有序性**



> 为了性能优化，JVM会在不改变`数据依赖性`的情况下，允许`编译器和处理器对指令序列进行重排序`，而有序性问题指的就是程序代码执行的顺序与程序员编写程序的顺序不一致，导致程序结果不正确的问题。而加了volatile修饰的共享变量，则通过`内存屏障`解决了多线程下有序性问题。



**volatile的有序性是通过禁止指令重排序实现的**



> 重排序可以提高代码的执行效率，但在多线程程序中可以导致程序的运行结果不正确那volatile是如何解决这一问题的呢？





**在volatile「前后」加上「内存屏障」，使得编译器和CPU无法进行重排序，致使有序，并且写volatile变量对其他线程可见。**



为了实现volatile的内存语义，**编译器在生成字节码时会通过插入内存屏障来禁止指令重排序**



> 内存屏障：
>
> 内存屏障是一种CPU指令，它的作用是对该指令前和指令后的一些操作产生一定的约束，保证一些操作按顺序执行。



 





## 内存屏障



Java内存模型把内存屏障分为4类，如下表所示：



![img](../../images/MESI&&volatile/v2-21759d51a9bc8f17b8f639e5887946fb_720w.jpg)



StoreLoad Barriers同时具备其他三个屏障的作用，它会使得该屏障之前的所有内存访问指令完成之后，才会执行该屏障之后的内存访问命令。



Java内存模型对编译器指定的**volatile重排序**规则为：

- 当第一个操作是volatile读时，无论第二个操作是什么都不能进行重排序。
- 当第二个操作是volatile写时，无论第一个操作是什么都不能进行重排序。
- 当第一个操作是volatile写，第二个操作为volatile读时，不能进行重排序。





根据volatile重排序规则，Java内存模型采取的是保守的屏障插入策略，volatile写是在前面和后面分别插入内存屏障，volatile读是在后面插入两个内存屏障，具体如下：



- **volatile读**：在每个volatile读后面分别插入LoadLoad屏障及LoadStore屏障（根据volatile重排序规则第一条），如下图所示

![img](../../images/MESI&&volatile/v2-0987b145881104add705865512571377_720w.jpg)

LoadLoad屏障的作用：禁止上面的所有普通读操作和上面的volatile读操作进行重排序。

LoadStore屏障的作用：禁止下面的普通写和上面的volatile读进行重排序。

- **volatile写**：在每个volatile写前面插入一个StoreStore屏障（为满足volatile重排序规则第二条），在每个volatile写后面插入一个StoreLoad屏障（为满足voaltile重排序规则第三条），如下图所示

![img](../../images/MESI&&volatile/v2-e96e58c54517c2515a5d675e861e3c17_720w.jpg)


StoreStore屏障的作用：禁止上面的普通写和下面的volatile写重排序
StoreLoad屏障的作用：防止上面的volatile写与下面可能出现的volatile读/写重排序。









# volatile不保证原子性





老王：**如果要保证原子性的话，落到底层实际还是需要进行加锁的，需要保证任意时刻只能有一个线程能执行成功**。











