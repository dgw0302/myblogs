---
title: JMM
categories:
  - 多线程与并发
tags:
  - JMM
abbrlink: 56288
date: 2022-04-9 19:54:20
---



# 什么是JMM模型



并发体系：https://www.processon.com/view/link/615d4a610e3e74663e97fa0e#map



***前提声明** ：**java内存模型不是运行时数据区那个东西，那个是java内存结构，不要搞混***



java内存模型（java memory model）是一种抽象的概念，并不真实存在，它描述的一组规则或者规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

**jmm模型如下图**

![https://note.youdao.com/yws/public/resource/e59837f57323a12defbb62fa837b330d/xmlnote/22CDFD1BD5BE4B9B9877018340E33360/14414](../../images/jmm/14414)



还有一张图也可以很好的解释**jmm**

![image-20220409162607766](../../images/jmm/image-20220409162607766.png)



图中内存分为住内存和工作内存，主内存是共享的，工作内存是每个线程私有的，各个线程之间获取不到其他线程工作内存的数据，这个工作内存是抽象出来的，其物理实现可能是由cpu的三级缓存、寄存器等等组成，各个线程的工作内存存的是主内存的变量副本。



**主内存**

主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。

**工作内存**

主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。



**工作内存与主内存的数据交互是8个原语实现的。**

（1）**lock(锁定)**：作用于主内存的变量，把一个变量标记为一条线程独占状态

（2）**unlock(解锁)**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

（3）**read(读取)**：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

（4）**load(载入)**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中

（5）**use(使用)**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎

（6）**assign(赋值)**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量

（7）**store(存储)**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作

（8）**write(写入)**：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中





# 工作内存与主内存（**※**）

JMM模型下的工作内存与主内存是抽象概念

对于硬件内存来说只有**寄存器、缓存内存、主内存**的概念，并没有**工作内存和主内存**之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响，因为JMM只是一种抽象的概念，是一组规则，并不实际存 在，**不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，**因此总体上来说，Java内存模型和计算 机硬件内存架构是一个**相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。**



**一般一级缓存与二级缓存是每个核心进行分别均衡分配的，三级缓存才是多个核心一起共享的。**



工作内存目前知道的是：包括cpu三级高速缓存、寄存器、线程栈等等。而且工作内存是主内存的变量副本



**工作内存是逻辑概念，与硬件内存架构之间存在差异。**



![image-20220816185929090](../../images/jmm/image-20220816185929090.png)





每个线程都有自己的线程栈，而线程栈都有自己的独立空间









## 什么时候工作内存的变量修改值刷回主内存？

不知道？反正不是立即刷回主内存的，所以会产生多线程之间的不可见性问题





# 伪共享（**※**）



[外部]: https://mp.weixin.qq.com/s/trxhrJBcr4LCSFPdatF_tA



https://mp.weixin.qq.com/s/trxhrJBcr4LCSFPdatF_tA



**缓存中的基本存储单元就是 Cache Line**。

每个 Cache Line 通常是 64 字节，也就是说，一个 Java 的 `long` 类型变量是 8 字节，一个 Cache Line 中可以存 8 个 `long` 类型的变量。





在程序运行的过程中，**由于缓存的基本单元 Cache Line 是 64 字节，所以缓存每次更新都会从内存中加载连续的 64 个字节**。





如果访问的是一个 `long` 类型数组的话，当数组中的一个值比如 v1 被加载到缓存中时，接下来地址相邻的 7 个元素也会被加载到缓存中。（这也能解释为啥我们数组总是能够这么快，像链表这种离散存储的数据结构，就无法享受到这种红利）。



## 举例

举个例子，**如果我们定义了两个 `long` 类型的变量 a 和 b，他们在内存中的地址是紧挨着的，会出现什么问题**？







如果我们想要访问 a 的话，那么 b 也会被存储到缓存中来。

懵了懵了，这有什么问题吗，看起来似乎没有什么毛病，多么 nice 的特性啊





回想下上文提到的 CPU 和三级缓存以及内存的对应使用关系，设想这种情况，如果一个 CPU 核心的线程 T1 在对 a 进行修改，另一个 CPU 核心的线程 T2 却在对 b 进行读取。





当 T1 修改 a 的时候，除了把 a 加载到 Cache Line，还会享受一波红利，把 b 同时也加载到 T1 所处 CPU 核心的 Cache Line 中来，对吧。





根据 MESI 缓存一致性协议，修改完 a 后这个 Cache Line 的状态就是 M（Modify，已修改），而其它所有包含 a 的 Cache Line 中的 a 就都不是最新值了，所以都将变为 I 状态（Invalid，无效状态）



这样，当 T2 来读取 b 时，诶，发现他所处的 CPU 核心对应的这个 Cache Line 已经失效了，mmp，它就需要花费比较长的时间从内存中重新加载了。









![image-20220816182447571](../../images/jmm/image-20220816182447571.png)





问题已经显而易见了，**b 和 a 没有任何关系，每次却要因为 a 的更新导致他需要从内存中重新读取，拖慢了速度**。这就是伪共享



表面上 a 和 b 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。









用更书面的解释来定义伪共享：**当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，导致无法充分利用缓存行特性，这就是伪共享**。









## 解决伪共享



1）**padding**：就是增大数组元素之间的间隔，使得不同线程存取的元素位于不同的缓存行上，以空间换时间



2）**JDK1.8 提供了 `@Contended` 注解**：就是把我们手动 padding 的操作封装到这个注解里面了，这个注解可以放在类上也可以放在字段上，这里就不多做说明了









# JMM与JVM

JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，**JMM是围绕原子性，有序性、可见性展开**。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。



# 存在的必要性

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题





# as-if-serial规则



as-if-serial语义的意思指：不管怎么[重排序](https://so.csdn.net/so/search?q=重排序&spm=1001.2101.3001.7020)（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守as-if-serial语义





# happens-before规则



上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。



##     具体规则

程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。
程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。
对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。













**as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。**





















































































































