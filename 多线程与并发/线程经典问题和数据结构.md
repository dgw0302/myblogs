---
title: 数据结构&&并发
categories:
  - 多线程与并发
tags:
  - 线程数据结构问题
abbrlink: 55249
date: 2022-04-13 00:00:00
---





[TOC]



# 并发

## 两个线程轮流打印奇偶数。

```java
public class Test {
    private  static int count = 0;
    private static final Object object = new Object();
    public static void main(String[] args) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (count < 100) {
                    synchronized (object) {
                        if(count % 2 == 0) {
                            System.out.println(Thread.currentThread().getName() +"  "+ count++ +"偶数线程");
                        }
                    }
                }
            }
        }).start();


        new Thread(new Runnable() {
            @Override
            public void run() {
                while (count < 100) {
                    synchronized (object) {
                        if(count % 2 != 0) {
                            System.out.println(Thread.currentThread().getName() + " " + count++ +"奇数线程");
                        }
                    }
                }
            }
        }).start();

    }
}
```



## 三个线程轮流打印ABC

完整代码如下

```java
public class ABC2 {

    private static Lock lock = new ReentrantLock();
    private static Condition A = lock.newCondition();
    private static Condition B = lock.newCondition();
    private static Condition C = lock.newCondition();
    private static int count = 0;
    static class ThreadA extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 0)//注意这里是不等于0，也就是说在count % 3为0之前，当前线程一直阻塞状态
                        A.await(); // A释放lock锁
                    System.out.print("A");
                    count++;
                    B.signal(); // A执行完唤醒B线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }


    static class ThreadB extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 1)
                        B.await();// B释放lock锁，当前面A线程执行后会通过B.signal()唤醒该线程
                    System.out.print("B");
                    count++;
                    C.signal();// B执行完唤醒C线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
    
    
    static class ThreadC extends Thread {
        @Override
        public void run() {
            try {
                lock.lock();
                for (int i = 0; i < 10; i++) {
                    while (count % 3 != 2)
                        C.await();// C释放lock锁，当前面B线程执行后会通过C.signal()唤醒该线程
                    System.out.print("C");
                    count++;
                    A.signal();// C执行完唤醒A线程
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
    
    public static void main(String[] args) {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();

    }
    
}
```





分析其中一个线程A

全文维护一个count值，当值取模0打印A并自增，B、C也是如此



有A B C三个condition,内部都维护一个条件队列

```java
static class ThreadA extends Thread {
    @Override
    public void run() {
        try {
            lock.lock();
            for (int i = 0; i < 10; i++) {//一共打印10次，线程会在不断循环，到它打印就打印，要么就阻塞等待下次打印，直到循环完
                while (count % 3 != 0)//注意这里是不等于0，也就是说在count % 3为0之前，当前线程一直阻塞状态
                    A.await(); // 如果现在不是轮到到他打印，那么就加入条件队列，并释放锁资源，并且阻塞。
                
                System.out.print("A");//到这儿了说明轮到他打印了
                count++;//加1
                B.signal(); // 打印完唤醒它之后应该打印的线程，具体怎样唤醒呢，调用其所在的condition,将其在条件队列里面的线程调至CLH队列去抢锁
                
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



**当启动三个线程时，为什么能控制A线程第一个打印A呢，毕竟线程基本上是同时启动的？**



解释

```java
while (count % 3 != 0)//注意这里是不等于0，也就是说在count % 3为0之前，当前线程一直阻塞状态
A.await(); // 如果现在不是轮到到他打印，那么就加入条件队列，并释放锁资源，并且阻塞。
```

就在这个循环判断逻辑里面

当三个线程同时启动，运行到自己这个while循环逻辑时候，只有A线程能跳过while循环，其他两个都到其condition所在的条件队列里面了并且阻塞，等待前一个打印线程去signal()唤醒它







备注：开始的时候启动三个线程，无论是谁先拿到锁，如果轮不到自己打印，都会被自己队列的await方法阻塞，释放锁，并进入对应的condition条件队列。



如果轮到自己打印了，打印完之后，count++,会调用接下来的线程对应的conditin队列signal,唤醒线程，也就是把队头结点移动到AQS内部的同步队列去等待被唤醒，然后**tryAcquire获取锁**。拿到锁了才会进行下面的逻辑，否则在acquireQueued方法会一直自旋（注意当前线程在下一次循环count取模不是自己会释放锁并阻塞自己）如果对应的线程被唤醒了并获取到锁了，也是相同的逻辑。











# 生产者消费者实现





## BlockingQueue实现



BlockingQueue即阻塞队列，从阻塞这个词可以看出，在某些情况下对阻塞队列的访问可能会造成阻塞。被阻塞的情况主要有如下两种:

1. 当队列满了的时候进行入队列操作
2. 当队列空了的时候进行出队列操作
   因此，当一个线程对已经满了的阻塞队列进行入队操作时会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作时也会阻塞，除非有另外一个线程进行了入队操作。
   从上可知，阻塞队列是线程安全的。
   下面是BlockingQueue接口的一些方法:

| 操作 | 抛异常     | 特定值   | 阻塞    | 超时                        |
| ---- | ---------- | -------- | ------- | --------------------------- |
| 插入 | add(o)     | offer(o) | put(o)  | offer(o, timeout, timeunit) |
| 移除 | remove(o)  | poll(o)  | take(o) | poll(timeout, timeunit)     |
| 检查 | element(o) | peek(o)  |         |                             |

这四类方法分别对应的是：
1 . ThrowsException：如果操作不能马上进行，则抛出异常
2 . SpecialValue：如果操作不能马上进行，将会返回一个特殊的值，一般是true或者false
3 . Blocks:如果操作不能马上进行，操作会被阻塞
4 . TimesOut:如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是true或者false
下面来看由阻塞队列实现的生产者消费者模型,这里我们使用take()和put()方法，这里生产者和生产者，消费者和消费者之间不存在同步，所以会出现连续生成和连续消费的现象

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
/**
 * 使用BlockingQueue实现生产者消费者模型
 * @author ZGJ
 * @date 2017年6月29日
 */
public class Test3 {
    private static Integer count = 0;
    //创建一个阻塞队列
    final BlockingQueue blockingQueue = new ArrayBlockingQueue<>(10);
    public static void main(String[] args) {
        Test3 test3 = new Test3();
        new Thread(test3.new Producer()).start();
        new Thread(test3.new Consumer()).start();
        new Thread(test3.new Producer()).start();
        new Thread(test3.new Consumer()).start();
        new Thread(test3.new Producer()).start();
        new Thread(test3.new Consumer()).start();
        new Thread(test3.new Producer()).start();
        new Thread(test3.new Consumer()).start();
    }
    class Producer implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(3000);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                try {
                    blockingQueue.put(1);
                    count++;
                    System.out.println(Thread.currentThread().getName()
                            + "生产者生产，目前总共有" + count);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    class Consumer implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
                try {
                    blockingQueue.take();
                    count--;
                    System.out.println(Thread.currentThread().getName()
                            + "消费者消费，目前总共有" + count);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```




## 信号量Semaphore的实现

Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源，在操作系统中是一个非常重要的问题，可以用来解决哲学家就餐问题。Java中的Semaphore维护了一个许可集，一开始先设定这个许可集的数量，可以使用acquire()方法获得一个许可，当许可不足时会被阻塞，release()添加一个许可。在下列代码中，还加入了另外一个mutex信号量，维护生产者消费者之间的同步关系，保证生产者和消费者之间的交替进行

```java
import java.util.concurrent.Semaphore;
/**
 * 使用semaphore信号量实现
 * @author ZGJ
 * @date 2017年6月29日
 */
public class Test4 {
    private static Integer count = 0;
    //创建三个信号量
    final Semaphore notFull = new Semaphore(10);
    final Semaphore notEmpty = new Semaphore(0);
    final Semaphore mutex = new Semaphore(1);
    public static void main(String[] args) {
        Test4 test4 = new Test4();
        new Thread(test4.new Producer()).start();
        new Thread(test4.new Consumer()).start();
        new Thread(test4.new Producer()).start();
        new Thread(test4.new Consumer()).start();
        new Thread(test4.new Producer()).start();
        new Thread(test4.new Consumer()).start();
        new Thread(test4.new Producer()).start();
        new Thread(test4.new Consumer()).start();
    }
    class Producer implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    notFull.acquire();
                    mutex.acquire();
                    count++;
                    System.out.println(Thread.currentThread().getName()
                            + "生产者生产，目前总共有" + count);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    mutex.release();
                    notEmpty.release();
                }
            }
        }
    }
    class Consumer implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
                try {
                    notEmpty.acquire();
                    mutex.acquire();
                    count--;
                    System.out.println(Thread.currentThread().getName()
                            + "消费者消费，目前总共有" + count);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    mutex.release();
                    notFull.release();
                }
            }
        }
    }
}
```

## 可重入锁ReentrantLock的实现（主）

java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，通过对lock的lock()方法和unlock()方法实现了对锁的显示控制，而synchronize()则是对锁的隐性控制。
可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响，简单来说，该锁维护这一个与获取锁相关的计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，函数调用结束计数器就减1，然后锁需要被释放两次才能获得真正释放。已经获取锁的线程进入其他需要相同锁的同步代码块不会被阻塞。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
/**
 * 生产者和消费者，ReentrantLock的实现
 * 
 * @author ZGJ
 * @date 2017年6月22日
 */
public class Test2 {
    
    //此时是用一个count变量来代替队列
    private static Integer count = 0;
    private static final Integer FULL = 10;
    //创建一个锁对象
    private Lock lock = new ReentrantLock();
    //创建两个条件变量，一个为缓冲区非满，一个为缓冲区非空
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    public static void main(String[] args) {
        Test2 test2 = new Test2();
        new Thread(test2.new Producer()).start();
        new Thread(test2.new Consumer()).start();
        new Thread(test2.new Producer()).start();
        new Thread(test2.new Consumer()).start();
        new Thread(test2.new Producer()).start();
        new Thread(test2.new Consumer()).start();
        new Thread(test2.new Producer()).start();
        new Thread(test2.new Consumer()).start();
    }
    class Producer implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(3000);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                //获取锁
                lock.lock();
                try {
                    while (count == FULL) {
                        try {
                            
                            //队列满了，那么不满的condition就阻塞
                            notFull.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    count++;
                    System.out.println(Thread.currentThread().getName()
                            + "生产者生产，目前总共有" + count);
                    //唤醒消费者
                    notEmpty.signal();
                } finally {
                    //释放锁
                    lock.unlock();
                }
            }
        }
    }
    class Consumer implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
                lock.lock();
                try {
                    while (count == 0) {
                        try {
                            //队列空了，那么不空的condition就阻塞
                            notEmpty.await();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                    count--;
                    System.out.println(Thread.currentThread().getName()
                            + "消费者消费，目前总共有" + count);
                    notFull.signal();
                } finally {
                    lock.unlock();
                }
            }
        }
    }
}
```











# 阻塞队列实现

```java


class ArrayBlockingQueue{
  int size = 10;
  Deque queue = new ArrayDeque();
  ReetrantLock lock = new ReetrantLock();
  Condition notEmpty = lock.newCondition(), notFull = lock.newCondition();
    
  //不空存消费者
  //不满存生产者
    
  Object poll() {
    lock.lock();
    try {
      while (queue.isEmpty()) {
          //当队列为空了，那么不空的condition就阻塞消费者
        notEmpty.await();
      }
      Object res = queue.pollFirst();
      //队列里面有数据了，唤醒不满condition，生产者
      notFull.signal();
      return res;
    } catch (Exception e) {
      //
    } finally {
      lock.unlock();
    }
  }
  void offer(Object object) {
    lock.lock();
    try {
      while (queue.size() == size) {
          //当队列满了，阻塞不满condition，阻塞x'z
          
        notFull.await();
      }
      queue.offer(object);
        
        //队列消费完元素了
        //唤醒不空condition
      notEmpty.signal();
      return;
    } catch (Exception e) {
      //
    } finally {
      lock.unlock();
    }
  }
}
```







# 无锁并发队列

基于CAS



```java
import java.util.concurrent.atomic.AtomicInteger;
 
public class ConcurrentLoopQueue {
    private int capacity;
    private AtomicInteger head;
    private AtomicInteger tail;
    private volatile Integer[] array;
 
 
    public ConcurrentLoopQueue(int capacity) {
        this.capacity = capacity;
        array = new Integer[capacity];
        head = new AtomicInteger(0);
        tail = new AtomicInteger(0);
    }
 
 
    public boolean enqueue(Integer ele){
        boolean flag = true;
        int preTail = 0;
        int nextTail = 0;
        while(flag){
            preTail = tail.get();
            if((preTail + 1) % capacity == head.get()){ //队列已满
                return false;
            }
 
            nextTail = (preTail + 1) % capacity;
            if(tail.compareAndSet(preTail,nextTail)){
                array[preTail] = ele;
                return true;
            }
        }
        return false;
    }
 
    public Integer dequeue(){
        int preHead = 0;
        int nextHead = 0;
        boolean flag = true;
        while(flag){
            preHead = head.get();
            if(preHead == tail.get()){ // 队列空
                return null;
            }
            nextHead = (preHead + 1) % capacity;
            if(head.compareAndSet(preHead,nextHead)){
                return array[preHead];
            }
        }
        return null;
    }
}
```







> 需要注意的是:
>
> - 1.环形队列的是否已满的判断条件；
>
>   普通环形队列的判满条件是：tail == capacity;但是环形队列是把线型的数组掰成了环状，判满条件就变成了(tail + 1)%capacity==head。
>
> 
>
> - 2.虽然程序中有两类临界资源，但是在并发操作中，其实最直接的临界资源是tail和head，不是存放数据的数组。因为每个线程是先获得数组下标(tail或者head)，然后再操作对应的数组位置，只要能保证tail或者head的线程安全，基本上接下来的操作也就是线程安全的了。





# 手写HashMap

## map接口

```java
public interface Map<K,V> {
    V put(K k, V v);

    V get(K k);

    int size();

    V remove(K k);

    boolean isEmpty();

    void clear();
}
```

## Node结点

```java
class Node<K,V> {
    K k;
    V v;
    Node<K,V> next;
    public Node(K k,V v, Node<K,V> next) {
        this.k = k;
        this.v = v;
        this.next = next;
    }
}
```



## MyHashMap

```java
public class MyHashMap<K,V> implements Map<K,V> {


    //默认初始化容量
    final static int DEFAULT_CAPACITY = 16;
    //默认加载因子
    final static float DEFAULT_LOAD_FACTOR = 0.75f;

    //容量
    int capacity;
    //加载因子
    float loadFactor;

    //数组
    Node<K,V>[] table;

    //哈希表的所有结点
    int size;

    public MyHashMap(int capacity, float loadFactor) {
        this.capacity = capacity;
        this.loadFactor = loadFactor;
    }


    public MyHashMap() {
        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }


    @Override
    public V put(K k, V v) {


        int index = k.hashCode() % table.length;
        Node<K,V> current = table[index];

        if(current == null) {
            //如果table[index] 为null,直接赋值
            table[index] = new Node<K,V>(k,v,null);
            size++;
        }else {
            //遍历链表
            while (current != null) {
                if(current.k == k) {
                   V oldValue = current.v;
                   //新value覆盖旧value
                   current.v = v;
                   return oldValue;
                }
                current = current.next;
            }

            //如果链表没有相同的key就头插
            //右边的table[index] 是旧的第一个结点，当前结点插入这个旧的结点前面
            table[index] = new Node<K,V>(k,v,table[index]);
            size++;
            return null;
         }
        return null;
    }

    @Override
    public V get(K k) {
        int index = k.hashCode() % table.length;

        Node<K,V> current = table[index];

       while (current != null) {
           if(current.k == k) {
               return current.v;
           }
           current = current.next;
       }
        return null;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public V remove(K k) {
        int index = k.hashCode() % table.length;
        Node<K,V> current = table[index];
         //如果直接匹配第一个结点
        if(current.k == k && current.next == null) {
            table[index] = null;
            size--;
            return current.v;
        }

        //在链表中删除结点
        while (current.next != null) {
            if(current.next.k == k) {
                V oldValue = current.next.v;
                current.next = current.next.next;
                size--;
                return oldValue;
            }
            current = current.next;
        }
        return null;
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public void clear() {

    }
}
```





















# LRU

哈希表加上双向链表



```java
class LRUCache {、
    /*
    一个Node结点类
    一个双向链表 链表结点为Node结点
    一个hashmap key为int value为Node
    一个capacoty 一个size
    一个put 一个get 
    一个addToHead   （真实操作，把结点添加至链表头部，一般用于新插入的结点）
    一个RemoveNode （相当于辅助操作，删除节点）
    一格MoveToHead  （把链表结点从原来的位置移动至链表头部）
    一个RemoveTail  （把虚拟尾结点前的结点删除并返回，为什么要返回？还得根据返回的结点删除在HashMap对应的结点）
    
    */

     class Node {
         int key;
         int value;
         Node pre;
         Node next;
         public Node() {};
         public Node(int key, int value) {
             this.key = key;
             this.value = value;
         }
     }

     public Map<Integer, Node> map = new HashMap<Integer, Node>();

     public int  capacity;

     int size;
     public Node head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {

        Node node = map.get(key);
        if(node == null) return -1;

        MoveToHead(node);
        return node.value;

    }
    
    public void put(int key, int value) {
        Node node = map.get(key);
        if(node == null) {
            Node newNode =  new Node(key, value);
            map.put(key, newNode);
            addToHead(newNode);
            size++;

            if(size > capacity) {
            Node  tailpre   = RemoveTail();
            map.remove(tailpre.key);    
            size--;
            }


        } else {
            node.value = value;
            MoveToHead(node);

        }

    }

    public void addToHead(Node node) {
        node.pre = head;
        node.next = head.next;
        node.next.pre = node;
        head.next = node;

    }

    public void RemoveNode(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }


    public void MoveToHead(Node node) {
        RemoveNode(node);
        addToHead(node);
    }

    public Node RemoveTail() {
         Node t =  tail.pre;
        RemoveNode(tail.pre);
        return t;
    }
    
    







}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```



## 优化



上面的LRU算法还有一些不足：当热点数据较多时，有较高的命中率，但是如果有偶发性的批量操作，会使得热点数据被非热点数据挤出容器。

那就出现了LRU-K，它是对上面LRU算法的改进，可以说上面的基础LRU是LRU-1，LRU-K是将原先进入缓存队列的评判标准从访问一次改为访问K次。

LRU-K算法有两个队列，一个是缓存队列，一个是数据访问历史队列。当访问一个数据时，首先先在访问历史队列中累加访问次数，当历史访问记录超过K次后，才将数据缓存至缓存队列，从而避免缓存队列被污染。同时访问历史队列中的数据可以按照LRU的规则进行淘汰。



![在这里插入图片描述](../../images/%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rKZ5rupZGXmtYHmspk=,size_19,color_FFFFFF,t_70,g_se,x_16.png)







```java
// 直接继承我们前面写好的LRUCache
public class LRUKCache extends LRUCache {
    
    private int k; // 进入缓存队列的评判标准
    private LRUCache historyList; // 访问数据历史记录

    public LRUKCache(int cacheSize, int historyCapacity, int k) {
        super(cacheSize);
        this.k = k;
        this.historyList = new LRUCache(historyCapacity);
    }

    @Override
    public Integer get(Integer key) {

        // 记录数据访问次数
        Integer historyCount = historyList.get(key);
        historyCount = historyCount == null ? 0 : historyCount;
        historyList.put(key, ++historyCount);

        return super.get(key);
    }

    @Override
    public Integer put(Integer key, Integer value) {

        if (value == null) {
            return null;
        }
        
        // 如果已经在缓存里则直接返回缓存中的数据
        if (super.get(key) != null) {
            return super.put(key, value);;
        }

        // 如果数据历史访问次数达到上限，则加入缓存
        Integer historyCount = historyList.get(key);
        historyCount = historyCount == null ? 0 : historyCount;
        if (historyCount >= k) {
            // 移除历史访问记录
            historyList.remove(key);
            return super.put(key, value);
        }
    }
}

```









## 并发版





![img](../../images/%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/EE7D0CB04969F749DE91D51E0F4B670E.jpg)



加锁把 





# LFU

**衰减**





# KMP

字符串模式匹配

![image-20220424165935010](../images/%E5%88%86%E7%B1%BB%E9%A2%98%E7%9B%AE/image-20220424165935010.png)



## **解法**一



### 求next数组



```java
public int[] getNext(String s){
    int i = 0;
    int j = -1;
    int n = s.length();
    
    int[] next = new int[n];
    next[0] = -1;

    while(i < n - 1){
        if(j == -1 || s.charAt(i) == s.charAt(j)){
            i += 1;
            j += 1;
            next[i] = j;
        }else{
            j = next[j];
        }
    }
    return next;
}
```



```java
class Solution {
     //kmp求next数组
     public int[] getNext(String s) {
         int i = 0;
         int j = -1;
         
         int n = s.length();

         int[] next = new int[s.length()];
         next[0] = -1;
         while(i < n - 1) {
             if(j == -1 || s.charAt(i) == s.charAt(j)) {
                 i++;
                 j++;
                 next[i] = j;
             }else{
                 j = next[j];
             }
         }
         return next;

     }
   
    public boolean repeatedSubstringPattern(String s) {
           if(s.length() == 0) return false;
           int n = s.length();
           int[] next = getNext(s);
           int len = next[s.length() - 1] + 1;
           
           if(len == 0 || s.charAt(n - 1) != s.charAt(n - 1 - len)) return false;

            return  n % (n - len) == 0;

    }


}
```







## 解法二

```java
class Solution{
    public boolean repeatedSubstrinngPattern(String s){
        //创建一个新的字符串，由两个字串连接
    String str = s+s;
    return str.subString(1,str.length()-1).contains(s);//去掉头和尾，再来看是否有重复的，下面画个图
    // s=abab  s+s=abababab
    //去掉首尾后 str=bababa ,那么一定能找到和s一样的，那么也就代表有重复的字串了
}
}


class Solution {
public  boolean repeatedSubstringPattern(String s) {
    int len = s.length();
        if (len == 0)  return false;  
        int[] next = getNext(s.toCharArray());
        if (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) return true;
        return false;
    }

    public int[] getNext(char[] sArr){
        int[] next = new int[sArr.length];
        int j = 0; //j:前缀末尾
        for(int i = 1; i < next.length; i++){ //i:后缀末尾
            while(j > 0 && sArr[i] != sArr[j])  j = next[j - 1];
            if(sArr[i] == sArr[j])  j++;
            next[i] = j;
        }
        return next;   

    }
}
```







# 数据结构

## 排序

桶排序 计数排序 基础排序 

快排 归并 堆排序

见[Category: 数据结构与算法 | D_W? (gitee.io)](https://dgw_521.gitee.io/categories/数据结构与算法/)



## 常用topk问题

见[Category: 数据结构与算法 | D_W? (gitee.io)](https://dgw_521.gitee.io/categories/数据结构与算法/)



# 海量数据问题

见[Category: 数据结构与算法 | D_W? (gitee.io)](https://dgw_521.gitee.io/categories/数据结构与算法/)



直接看这个吧：https://doocs.github.io/advanced-java/#/docs/big-data/find-common-urls



## Arrays.sort()原理



## 海量数据排序问题

> ### 多路归并
>
> 海量数据不能一次性读入内存，在对海量数据进行排序时，首先需要将海量数据拆分到多台机器或者多个文件，这些机器或文件称为拆分节点；然后在每个拆分节点上将数据全部读入内存并使用快速排序等方法进行排序；最后在合并节点使用多路归并方法将所有拆分节点的部分排序结果整合成最终的排序结果。外部排序也可以被称为外部归并排序。
>
>
> 如果不进行额外处理，合并节点仍然无法将所有数据读入内存中。可以使用小顶堆来解决这个问题：
>
> 假设有 k 个拆分节点，从这 k 个拆分节点分别读取一个最小的数据到小顶堆中。
> 将堆顶数据移出堆并写入合并节点的最终结果文件中。
> 确定刚才从堆中移除的数据属于哪个拆分节点，并从该拆分节点再读入一个数据。
>
> 海量数据排序最后归并得在内存维护一个小顶堆
>
> 
>
> ### bitmap
>
> 先去重再用Bitmqp





**大数据小内存[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)问题**

- 数据库[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)（对数据库设备要求较高）
- 分治法（常见思路）
- 位图法（Bitmap）



> ## 1. 数据库[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)
>
> 将存储着 100 亿数据的文本文件一条一条导入到数据库中，然后根据某个字段建立索引，数据库进行索引[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)操作后我们就可以依次提取出数据追加到结果集中。
>
> 这种方法的特点就是操作简单， 运算速度较慢，对数据库设备要求较高
>
> ## 2. 分治法
>
> 假设 100 亿个数据都是 int 类型的数字
>
> 1 个 int 类型占 4 个字节（byte，B）
>
> 1 B = 8 位（bit）
>
> 1024 B（1024 B = 1KB） = 8 * 1024 bit
>
> 1024 * 1024 KB（1024KB = 1MB）= 1024 * 8 * 1024 bit
>
> 100 亿 int 型数字就是 100 亿 x 4B = 400 亿 B = 38146.97265625 MB 约等于 37.25GB
>
> 100 亿个 int 型数字大概占 37 个 G，2G 内存显然一次性是装不下的。
>
> 最常见的思路，拆分成一个一个的小文件来处理呗，最终再合并成一个排好序的大文件。
>
> 典型的分治法
>
> 1）把这个 37 GB 的大文件，用哈希或者直接平均分成若个小文件（比如 1000 个，每个小文件平均 38 MB 左右）
>
> 2）拆分完了之后，得到 1000 个 30 多 MB 的小文件，那么就可以放进内存里[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)了，可以用快速[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，归并[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，堆[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)等等
>
> 3）1000 个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用堆[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)来做 1000 路合并的操作（假设是从小到大[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，用小顶堆）：
>
> - 首先遍历 1000 个文件，每个文件里面取第一个数字，组成 `(数字, 文件号)` 这样的组合加入到堆里，遍历完后堆里有 1000 个 `(数字，文件号)` 这样的元素
> - 然后不断从堆顶 pop 元素追加到结果集，每 pop 一个元素，就根据它的文件号去对应的文件里，补虫一个元素进入堆中，直到那个文件中的元素被拿完
> - 按照上面的操作，直到堆被取空了，此时最终结果文件里的全部数字就是有序的了
>
> ## 3. 位图法（Bitmap）
>
> 位图法的基本思想就是利用一位（bit）代表一个数字，例如第 3 位上为 1，则说明 3 这个数字出现过，若为0，则说明 3 这个数字没有出现过。很简单~
>
> 上面分析过，1M = 8388608 bit（800 多万）
>
> 也就是说，**通过位图法，只需要 1M 的空间，我们就可以处理 800 多万级别的数据**
>
> Java 中没有 bit 这样的基本数据类型，最小数据类型是 `byte`，我们可以用 **byte 数组**来实现这个位图法
>
> byte 数组上的每一个元素都是 byte 类型，一个 byte 等于 8 个 bit，我们可以把 10 进制的 byte 用二进制的 bit 来表示，如下图：
>
> ![img](../../images/%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/20220320161702.png)
>
> 这样，byte 数组中的一个元素就能表示 8 个数字是否出现过，比如 byte[0] 可以表示 0 ~ 7 是否出现过，byte[1] 可以表示 8 ~ 15 是否出现过.....
>
> 全部处理完之后，我们**从前往后遍历一遍 byte 数组**就能获取到有序数据了，时间复杂度为 O(N)
>
> 
>
> java.util 封装了 `BitSet` 这样一个类，是位图法的典型实现
>
> ![img](../../images/%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/20220320162935.png)
>
> 底层用的 long 数组，一个 long 型数据占 8 个字节（64 位，也就是说 long 数组中的一个元素就可以表示 64 个数字否出现过），占比与只占 1 个字节的 byte（8 位） 来说，能存储的数据更多了
>
> ```
> BitSet bitSet = ``new` `BitSet();``bitSet.set(``0``, ``2``, ``true``);
> ```
>
> 上面的代码的含义是，第 `[0,2)` 位会被设置成 1，也就是说这个类会自动地生成一个 long 型的元素，二进制表示是 `.....(省略 60 个 0) 0011`，十进制表示就是 3
>
> 
>
> 位图法的缺点：
>
> - 可读性差（不是一般的差 🤔）
> - 位图存储的元素个数虽然比一般做法多，但是存储的元素大小受限于存储空间的大小。要想定义存储空间大小就需要实现知道存储的元素到底有多少
> - 对于有符号类型的数据，需要用 2 位来表示，比如 第 0 位和第 1 位表示 0 这个数据，第 2 位和第 3 位表示 1 这个数据......，这会让位图能存储的元素个数，元素值大小上限减半





## 海量数据topk问题

**直接看博客**https://blog.csdn.net/weixin_45394002/article/details/123575988





```java
第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存前10000个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的10000个数还小，那么容器内这个10000个数就是最大10000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即10000。

第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100*10000个数据里面找出最大的10000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。 

第四种方法是Hash法。如果这1亿个书里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的10000个数。

第五种方法采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。
```









> 1、最简单的方法就是快排，取topk
>
> 2、局部淘汰法。用一个容器保存前k个数，然后将剩余的所有数字——与容器内的最小数字相比，如果所有后续的元素都比容器内的k个数还小，那么容器内这k个数就是最大k个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完所有的数，得到的结果容器中保存的数即为最终结果了
>
> 3、分治法。将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的10000个，最后在剩下的100* *10000个数据里面找出最大的10000个。100万个数据里面查找最大的10000个数据的方法如下：用快速排序的方法，将数据分为2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大的那堆个数N大于10000个，继续对大堆快速排序一次分成2堆，如果大堆个数N小于10000个，就在小的那堆里面快速排序一次，找第10000-n大的数字；递归以上过程，就可以找到第1w大的数。参考上面的找出第1w大数字，就可以类似的方法找到前10000大数字了。此种方法需要每次的内存空间为10^6*4=4MB，一共需要101次这样的比较。
>
> 4、采用最小堆。首先读入前10000个数来创建大小为10000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为10000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有10000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是10000（常数）。



## 海量数据去重

有个面试题： 请问有40亿个qq号存在一个文件里面。如何找出重复数量最多的前40个。要求只用10m内 存。

- 1.先分而治之将40亿qq号划分为多个子模块快排存储到多个文件中。
-  2.然后使用有限的内存合并多个子文件。（归并或者状态机）。
-  3.最后获取到完整的排序文件。 
- 4.使用位图或者排序树来筛选前40位。



## 海量数据找中位数

**csdn链接：**

https://blog.csdn.net/stpeace/article/details/108921752#:~:text=%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E5%A6%82%E4%B8%8B%EF%BC%9A%20Step1%3A,%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%B0%8F%E6%96%87%E4%BB%B6%E6%A1%B6%EF%BC%8C%E8%AE%BE%E5%AE%9A%E6%AF%8F%E4%B8%AA%E6%A1%B6%E7%9A%84%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%EF%BC%8C%E7%84%B6%E5%90%8E%E6%8A%8A%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%88%86%E9%85%8D%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E6%A1%B6%E4%B8%AD%EF%BC%8C%E5%B9%B6%E8%AE%B0%E5%BD%95%E6%A1%B6%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%E3%80%82%20Step2%3A%20%E6%A0%B9%E6%8D%AE%E6%A1%B6%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%87%BA%E4%B8%AD%E4%BD%8D%E6%95%B0%E6%89%80%E5%9C%A8%E7%9A%84%E6%A1%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E9%92%88%E5%AF%B9%E8%AF%A5%E6%A1%B6%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%B1%82%E5%87%BA%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%9A%84%E5%80%BC%E3%80%82




   Step1: 创建多个小文件桶，设定每个桶的取值范围，然后把海量数据元素分配到对应的桶中，并记录桶中元素的个数。

   Step2: 根据桶中元素的个数，计算出中位数所在的桶，然后针对该桶进行排序，就可以求出海量数据中位数的值。





**知乎引用**：https://zhuanlan.zhihu.com/p/75397875



还可以看看程序代码书





## 海量数据找最大的10个（不允许用堆）

![8a0060aa91a1e4358b57dc55d6a8a68.jpg](https://uploadfiles.nowcoder.com/images/20220901/318712518_1662040463175/837D1009E7FBDF0A15A8DCBEFC5A8767?x-oss-process=image%2Fresize%2Cm_mfit%2Cw_550%2Ch_550)



比特位分治，内部排序















## 如何从大量的 URL 中找出相同的 URL





### [题目描述](https://doocs.github.io/advanced-java/#/docs/big-data/find-common-urls?id=题目描述)

给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。















# Redis



## Redis跳表实现



```java
class Skiplist {
    /*
    Redis底层数据结构:跳表->以O(logN)的时间复杂度内完成增删改查指定元素
    核心原理:建立多层随机索引,将时间复杂度降至logN,具体可参考简书的博客
    重要函数:1.findClosest(node,level,num) (从curNode开始)寻找level内最靠近target的左边节点
            该位置就是在该层内最接近target且<target的位置,将来用于完成插入、删除、查找等操作
            2.randomLevel() 以0.25为概率因子生成最大值为32的随机数
            数字每增加1,出现的概率为前一个数的0.25倍
            如:1出现的概率为0.75;1以上出现的概率为0.25;
            2出现的概率就是0.25*0.75;3出现的概率就是0.25*0.75*0.75
            .......这样可以间接保证每一层的元素成类似于二叉树的结构,最大高度不过logN
    */
    // 随机数概率因子
    private static final double P_FACTOR = 0.25;
    // 最大层数
    private static final int MAX_LEVEL = 32;
    // 当前实际有效的最大层数
    private int curLevel;
    // 头结点
    Node head;

    /*
    节点类:值+同层右边的节点引用数组
    */
    class Node {
        int val;
        Node[] next;//每个结点，每一层对应的下一个结点，以数组存储
        
        public Node(int _val, int level) {
            val = _val;
            next = new Node[level];
        }
    }

    /*
    用给定规则生成随机数(非静态方法也可以调用静态变量)
    */
    private int randomLevel() {
        // 层数level从1开始
        int level = 1;
        while(Math.random() < P_FACTOR && level < MAX_LEVEL) {
            level++;
        }
        return level;
    }

    /*
    跳表构造器
    */
    public Skiplist() {
        // 一开始啥也没
        curLevel = 0;
        // head指出32个next的节点
        head = new Node(-1, MAX_LEVEL);
    }
    
    /*
    从curNode开始:
    寻找level层内最靠近target的左边节点(如target=6,5->6->7,停留在5;如target=6,5->7->8,停留在5)
    */
    private Node findClosest(Node curNode, int level, int target) {
        // curNode就是上一层下沉位置的开端
        while(curNode.next[level] != null && curNode.next[level].val < target) {
            curNode = curNode.next[level];
        }
        return curNode;
    }

    /*
    查找跳表内是否存在target元素
    */
    public boolean search(int target) {
        Node curNode = head;
        // 从有效的顶层开始搜索
        for(int i = curLevel - 1; i >= 0; i--) {
            // searchNode停留在<=target的左边
            curNode = findClosest(curNode, i, target);
            if(curNode.next[i] != null && curNode.next[i].val == target) {
                // 找到一个即可返回true
                return true;
            }
        }
        // 找遍所有层都找不到就返回false
        return false;
    }
    
    /*
    往跳表内添加元素num
    */
    public void add(int num) {
        // 随机层
        int level = randomLevel();
        // 随机层对应的新节点
        Node newNode = new Node(num, level);
        Node curNode = head;
        for(int i = curLevel - 1; i >= 0; i--) {
            // 找到要插入的位置
                //在每层找到最靠近target的左结点
            curNode = findClosest(curNode, i, num);
            // 当前层<newNode要求的层数时,每一层均要进行插入操作
            // 如level=2时,只要求索引为0,1的层进行插入
            if(i < level) {
                if(curNode.next[i] == null) {
                    // 目标位置处为空直接接上
                    curNode.next[i] = newNode;
                }else {
                    // 否则就要进行标准插入操作
                    Node tmp = curNode.next[i];
                    curNode.next[i] = newNode;
                    newNode.next[i] = tmp;
                }
            }
        }
        // 此时有可能要更新curLevel
          //此时有可能要更新curLevel,因为有可能随机层大于最大有效层,那就单打把大于有效层的索引加入
        if(level > curLevel) {
            for(int i = curLevel; i < level; i++) {
                head.next[i] = newNode;
            }
            curLevel = level;
        }
    }
    
    /*
    往跳表内删除元素num
    */
    public boolean erase(int num) {
        Node curNode = head;
        // 删除成功标记
        boolean flag = false;
        for(int i = curLevel - 1; i >= 0; i--) {
            curNode = findClosest(curNode, i, num);
            // 可能有多个相同的值(如果存在多个num删除其中任意一个即可)
            // 当出现多个重复值且前面节点层数低后面层数高,一层一层删下来其实删除的不是同一个节点
            // 但是不会影响最终结果
            if(curNode.next[i] != null && curNode.next[i].val == num) {
                // 进行删除操作
                curNode.next[i] = curNode.next[i].next[i];
                // 标记删除成功
                flag = true;
            }
        }
        return flag;
    }
}
```

### 并发安全版本

用CAS来实现并发安全，例如findClosest找到在每层找到最靠近target的左结点后（设这个结点叫node），CAS的替换这个node.next,依次来达到并发安全。





## Redis实现延时队列



### 场景

1.对于红包场景，账户 A 对账户 B 发出红包通常在 1 天后会自动归还到原账户。

2.对于实时支付场景，如果账户 A 对商户 S 付款 100 元，5秒后没有收到支付方回调将自动取消订单。



### 解决方案

### 方案一：

采用通过定时任务采用数据库/非关系型数据库轮询方案。

优点：

- 实现简单，对于项目前期这样是最容易的解决方案。

缺点：

1. DB 有效使用率低，需要将一部分的数据库的QPS分配给 JOB 的无效轮询。
2. 服务资源浪费，因为轮询需要对所有的数据做一次 SCAN 扫描 JOB 服务的资源开销很大。

### 方案二：

采用延迟队列：

优点：

1.  服务的资源使用率较高，能够精确的实现超时任务的执行。
2. 减少 DB 的查询次数，能够降低数据库的压力

缺点：

- 对于延迟队列来说本身设计比较复杂，目前没有通用的比较好过的方案。





**下面为redis延时队列实现**



先来看两个redis命令

 Zrangebyscore命令：返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员





```Redis
//返回所有符合条件 1 < score <= 5 的成员
ZRANGEBYSCORE zset (1 5

//返回所有符合条件 1 < score <= 5 的成员
ZRANGEBYSCORE zset (5 (10
```



### 思路

把当前时间戳和延时时间相加，也就是到期时间，存入Redis中，然后不断轮询，找到到期的，拿到再删除即可。



![img](../../images/Redis/509087-20200404111242306-943787231.png)











使用RedisTemplate作为Redis客户端连接,放在延时队列中的可以看成是一个个延时任务。





```java
@Data
public class DelayTask<T> {
	// 消息id
    private String id;
    // 任务名称
    private String taskName;
    // 具体任务内容
    private T msg;

}

```



**延时队列具体实现，主要分为放任务和轮询任务两个部分**



### 放任务+轮询任务

```java
public class RedisDelayQueue<T> {
    /**
     * 延迟队列名称
     */
    private String delayQueueName = "delayQueue";
  
    // 传入redis客户端操作
    public RedisDelayQueue(RedisTemplate redisTemplate,String delayQueueName)
    {
        this.redisTemplate = redisTemplate;
        this.delayQueueName = delayQueueName;
    }
    /**
     * 设置延迟消息
     */
    public void setDelayTasks(T msg, long delayTime) {
        DelayTask<T> delayTask = new DelayTask<>();
        delayTask.setId(UUID.randomUUID().toString());
        delayTask.setMsg(msg);
        
        //socre为当前时间+延时时间
        Boolean addResult = redisTemplate.opsForZSet().add(delayQueueName, JSONObject.toJSONString(delayTask), System.currentTimeMillis() + delayTime);
        if(addResult)
        {
            System.out.println("添加任务成功！"+JSONObject.toJSONString(delayTask)+"当前时间为"+ LocalDateTime.now());
        }
    }
    /**
     * 监听延迟消息
     */
    public void listenDelayLoop() {
        while (true) {
            // 获取一个到点的消息
            
            //拿比当前时间前一点的一条数据进行消费，查询最早的一条任务，来进行消费
            Set<String> set = redisTemplate.opsForZSet().rangeByScore(delayQueueName, 0, System.currentTimeMillis(), 0, 1);

            // 如果没有，就等等
            if (set.isEmpty()) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 继续执行
                continue;
            }
            // 获取具体消息的key
            String it = set.iterator().next();
            // 删除成功，zrem命令删除zset里面的value
            if (redisTemplate.opsForZSet().remove(delayQueueName, it) > 0) {
                // 拿到任务
                DelayTask delayTask = JSONObject.parseObject(it, DelayTask.class);
                // 后续处理
                System.out.println("消息到期"+delayTask.getMsg().toString()+",时间为"+LocalDateTime.now());
            }
        }
    }
}

```







### lua脚本

上面的算法中同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到 的进程都是白取了一次任务，这是浪费。可以考虑使用 lua scripting 来优化一下这个逻辑，将 zrangebyscore 和 zrem 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不 会出现这种浪费了















# 手写线程池

这个先等一会

简易版线程池

**核心线程数**

**最大线程数**

**工作队列**



```java
package 线程池;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicInteger;

public class ThreadPoolTrader implements Executor {

    //当前线程池有多少个线程
    public final AtomicInteger ctl = new AtomicInteger(0);

    //核心线程
    private volatile int cornPollSize;

    //最大线程
    private volatile int maximumPollSize;

    //工作队列

    private final BlockingQueue<Runnable> workQueue;

    public ThreadPoolTrader(int cornPollSize, int maximumPollSize, BlockingQueue<Runnable> workQueue) {
        this.cornPollSize = cornPollSize;
        this.maximumPollSize = maximumPollSize;
        this.workQueue = workQueue;
    }



    @Override
    public void execute(Runnable command) {

        int c = ctl.get();
        if(c < cornPollSize) {
            if(!addWorker(command)) {
                reject();
            }
        }
        /**
         * 先望工作队列里面提交
         *
         * 如果工作队列满了，尝试创建新线程（只要不大于maxmumPoolSize）
         */
        if(!workQueue.offer(command)) {
            if(!addWorker(command)) {
                reject();
            }
        }

    }

    private boolean addWorker(Runnable command) {
        if(ctl.get() > maximumPollSize) return  false;

        //创建worker类，并带着任务Runnable
        Worker worker = new Worker(command);
        worker.thread.start();
        ctl.incrementAndGet();
        return true;


    }






    //worker类
    private final class Worker implements Runnable{

        final Thread thread;
        Runnable firstTask;

        private Worker(Runnable firstTask) {
            this.thread = new Thread(this);
            this.firstTask = firstTask;
        }



        @Override
        public void run() {

            Runnable task = firstTask;
            try {
                //提交的任务完成之后开始从队列里面拿任务
                while(task != null || (task = getTask()) != null) {
                        task.run();
                        if(ctl.get() > maximumPollSize) {
                            break;
                        }
                       task = null;
                }

            } finally {
                        ctl.decrementAndGet();
            }

        }

        /**
         * 从工作队列里面拿任务
         * @return
         */
        private Runnable getTask() {
            for(; ;) {
                try {
                    System.out.println("workQueue.size：" + workQueue.size());
                    return workQueue.take();
                } catch (InterruptedException  e) {
                    e.printStackTrace();
                }
            }
        }

    }


    private void reject() {
        throw new RuntimeException("Error！ctl.count：" + ctl.get() + " workQueue.size：" + workQueue.size());
    }

    public static void main(String[] args) {
        ThreadPoolTrader threadPoolTrader = new ThreadPoolTrader(2, 2, new ArrayBlockingQueue<Runnable>(10));

        for(int i = 0; i < 10; i++) {

            int x = i;
            threadPoolTrader.execute(() -> {

                System.out.println("任务编号" + x);
            });
        }

    }


}
```





# 一致性哈希算法

**直接小林哥**

https://xiaolincoding.com/os/8_network_system/hash.html#%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%AF%B7%E6%B1%82





