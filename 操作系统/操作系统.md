---
title: 操作系统
categories:
  - 操作系统or网络
tags:
  - OS
abbrlink: 56288
date: 2022-03-9 19:4:20
---





[TOC]







# 进程与线程



## 僵尸进程

前面提到过，在 Linux 环境中，我们是通过 `fork` 函数来创建子进程的。创建完毕之后，父子进程独立运行，父进程无法预知子进程什么时候结束。

通常情况下，子进程退出后，父进程会使用 `wait` 或 `waitpid` 函数进行回收子进程的资源，并获得子进程的终止状态。

但是，如果父进程先于子进程结束，则子进程成为孤儿进程。孤儿进程将被 init 进程（进程号为1）领养，并由 init 进程对孤儿进程完成状态收集工作。

而如果子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程，



## 进程状态

三种基本状态

运行态

就绪态

阻塞态



**转换**



## 进程控制

进程控制就是要执行进程状态转换。







## 线程与多线程模型

可以把线程理解为“轻量级进程”

线程是一个基本的CPU执行单元，也是程序执行流的最小单位

引入线程提升了系统的**并发度**，使得一个进程内可以并发的处理各种任务



传统的进程间并发，需要切换进程的运行环境，系统开销很大。线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小，引入线程后，并发所带来的系统开销小。





**引入线程之后，进程是资源分配的基本单位，线程是调度的基本单位**



### 线程的属性

![image-20220310153959516](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220310153959516.png)



### 用户级线程与内核线程

![image-20220310161730990](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220310161730990.png)

**内核级线程：**

（1）线程的创建、撤销和切换等，都需要内核直接实现，即内核了解每一个作为可调度实体的线程。
 （2）这些线程可以在全系统内进行资源的竞争。
 （3）内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。
 在一定程度上类似于进程，只是创建、调度的开销要比进程小。有的统计是1：10

**用户级线程：**

（1）用户级线程仅存在于用户空间。
 （2）内核并不能看到用户线程。
 （3）内核资源的分配仍然是按照进程进行分配的；各个用户线程只能在进程内进行资源竞争



用户级线程是从用户视角看的线程

内核级线程才是处理机分配的单位。



### 多线程模型

#### 多对一

![image-20220310162029064](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220310162029064.png)



####  一对一

![image-20220310162343489](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220310162343489.png) 



#### 多对多

![image-20220310162523253](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220310162523253.png)



# 进程与线程（区别）

进程和线程到底共享哪些资源，哪些不能共享？

**共享：**

- 堆。 由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
- 全局变量 。它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
- 静态变量。 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和[全局变量](https://so.csdn.net/so/search?q=全局变量&spm=1001.2101.3001.7020)一样，存于堆中开辟的.bss和.data段，是共享的
- 文件等公用资源。 这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体

 

**独享**:

- 栈 :栈是独享的
- 寄存器 。 这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC

![image.png](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1647072259-ImRBOb-image.png)









## 总结



![image-20220820132551704](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220820132551704.png)









# 进程



## 进程通信方式

![image-20220820133025674](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220820133025674.png)





## 用户态和内核态

应用程序一般会在以下几种情况下切换到内核模式：

**1.系统调用**

**2.异常事件**

**3.设备中断**





# 内存管理







## 物理内存和虚拟内存



谈谈你对物理内存和虚拟内存的看法？



### 只有物理内存的缺点



操作系统有[虚拟内存](https://so.csdn.net/so/search?q=虚拟内存&spm=1001.2101.3001.7020)与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：

-   因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于**是没有得到分配资源的进程就只能等待。**当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的
-   由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的
-   因为内存时随机分配的，所以程序运行的地址也是不正确的。











**于是针对上面会出现的各种问题，虚拟内存就出来了。**

> 之前一篇文章中进程分配资源介绍过一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都认为自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)上，可能只对应的一点点的物理内存，实际用了多少内存，就会对应多少物理内存。
>
> 进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。









**进程开始要访问一个地址，它可能会经历下面的过程**

1.   每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
2.   所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
3.   进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
4.   页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
5.   当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
6.   缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。





![img](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI2OTgxNw==,size_16,color_FFFFFF,t_70.png)









### 虚拟内存是怎么工作的



当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。

另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）





页表在cpu的MMU原件里面

内存分页：**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。







**换入与换出**

如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为**换出**（*Swap Out*）。一旦需要的时候，再加载进来，称为**换入**（*Swap In*）。



更进一步地，分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是**只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。**



### 虚拟地址和物理地址是如何映射的？

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，**页表**包含物理页每页所在**物理内存的基地址**，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。

![img](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7884f4d8db4949f7a5bb4bbd0f452609.png)





总结一下，对于一个内存地址转换，其实就是这样三个步骤：

- **把虚拟内存地址，切分成页号和偏移量；**
- **根据页号，从页表里面，查询对应的物理页号；**
- **直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。**











### 利用虚拟内存机制的优点（重点）



 既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系
  当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存



  在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存，把碎片利用起来



内存保护：保护每个进程的地址空间不被其他进程破坏。



VM为每个进程提供了一致的地址空间，从而简化了链接、加载、内存共享等过程；







![img](https://p3-sign.toutiaoimg.com/b72400039afb66c7e371~noop.image?_iz=58558&from=article.pc_detail&x-expires=1661856452&x-signature=u2hz1LnXkYFuWrV6y3d9jX3kwbY%3D)







**缺页（指某个虚拟地址对应的物理地址没有缓存在内存中，只在磁盘里）**





# linux



## 查看进程

- top(动态)

  

- ps -aux

  

- ps -elf



## 查看进程优先级

ps ax -o nice,pid,comm





## 修改进程优先级



###  **开启某个进程并指定优先级**

```shell
nice -n 优先级数字 进程名字
nice -n 5 vim & 	//开启时指定vim的优先级为5
	//nice不是开启进程的命令，vim是开启进程
```



### **改变进程优先级**

```shell
renice -n 优先级数字 进程pid
renice -n 5 15589  	//开启后改变进程的优先级;只能加pid
```













## Linux系统查看正在使用的端口





### **使用 netstat 检查端口**



netstat 是一个[命令行工具](https://cloud.tencent.com/product/cli?from=10680)，可以提供有关网络连接的信息。

要列出正在侦听的所有 TCP 或 UDP 端口，包括使用端口和套接字状态的服务，请使用以下命令：netstat -tunlp

此命令中使用的选项具有以下含义：

-t – 显示 TCP 端口。-u – 显示 UDP 端口。-n – 显示数字地址而不是主机名。-l – 仅显示侦听端口。-p – 显示进程的 PID 和名称。仅当您以 root 或 sudo 用户身份运行命令时，才会显示此信息。

查询指定端口通过grep过滤：netstat -tnlp | grep :80













# IO模型

这篇文章写的比较好

https://juejin.cn/post/7046592392614379550#heading-17





https://www.cnblogs.com/aspirant/p/9166944.html





# 零拷贝



## 传统IO : read() + write()

1、**用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态**

2、DMA控制器把数据从硬盘中拷贝到内核读缓冲区

3、CPU把内核读缓冲区数据拷贝到用户缓冲区，上下文从内核态转为用户态，read()返回

4、**用户进程通过write()方法发起调用，上下文从用户态转为内核态**

5、CPU将用户缓冲区中数据拷贝到socket缓冲区/内核写缓冲区

6、DMA控制器把数据从socket缓冲区/内核写缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回



![在这里插入图片描述](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXdwNQ==,size_16,color_FFFFFF,t_70.jpeg)



## 零拷贝mmap

零拷贝技术是指计算机执行操作时，CPU**不需要**先将数据**从某处内存复制到另一个特定区域**，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。





### mmap+write：使用mmap代替read，减少一次CPU拷贝，节省一半的内存空间





mmap主要实现方式是将**内核读缓冲区**的地址和**用户缓冲区**的地址进行**映射**，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。



1、**用户进程通过mmap()方法向操作系统发起调用，上下文从用户态转向内核态**

2、DMA控制器把数据从硬盘中拷贝到内核读缓冲区

3、上下文从内核态转为用户态，mmap调用返回

4、**用户进程通过write()方法发起调用，上下文从用户态转为内核态**

5、CPU将内核读缓冲区中数据拷贝到socket缓冲区

6、DMA控制器把数据从socket缓冲区/内核写缓冲区拷贝到网卡，上下文从内核态切换回用户态，write()返回
![在这里插入图片描述](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXdwNQ==,size_16,color_FFFFFF,t_70-16607998452802.jpeg)











还有个零拷贝的实现技术**sendfile**













# 面视篇



## 内存缺页中断，尽量讲细一点



进程[线性](https://so.csdn.net/so/search?q=线性&spm=1001.2101.3001.7020)地址空间里的页面不必常驻内存，CPU在执行一条指令时，如果发现他要访问的页没有在内存中（即存在位为0），那么停止该指令的执行，并产生一个页不存在的异常，对应的故障处理程序可通过从外存加载该页的方法来排除故障，之后，原先引起的异常的指令就可以继续执行，而不再产生异常

> 
>
> **标准回答**
>
> 1. 概念
>
>    缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。当图访问已映射在虚拟地址空间中，但是并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。而如果访问是不被允许的，那么操作系统通常会结束相关的进程。
>
> 2. 分类
>
>    - 软性页缺失：指页缺失发生时，相关的页已经被加载进内存，但是没有向 MMU 注册的情况。操作系统只需要在 MMU 中注册相关页对应的物理地址即可。 
>    - 硬性页缺失：硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。 
>    - 无效页缺失：当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。 
>
> 3. 中断
>
>    中断是指计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序。
>
> **加分回答**
>
> 缺页中断发生时的事件顺序：
>
> - 硬件陷入内核，在堆栈中保存程序计数器，将当前指令的各种状态信息保存在特殊的 CPU 寄存器中； 
> - 保存通用寄存器和其他易失的信息，以免被操作系统破坏； 
> - 当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么； 
> - 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰； 
> - 如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用； 
> - 一旦页框“干净”后，操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面被装入后，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行； 
> - 当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态； 
> - 恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令； 
> - 调度引发缺页中断的进程，操作系统返回调用它的汇编语言程序； 
> - 该程序恢复寄存器和其他状态信息，返回到用户空间继续执行。



**在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中，每当所要访问的页面不存在时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。**



## 内部碎片与外部碎片



![image-20220907230345363](../../images/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20220907230345363.png)









## 死锁

直接小林









避免死锁：资源有序分配法，破坏环路等待条件

预防死锁：按照安全序列分配资源，具体的安全序列-银行家算法

如何避免进入不安全状态----银行家算法



当线程获取锁超时了则放弃，这样就避免了出现死锁获取的情况。



































































