---
title: mysql事务与锁机制
categories:
  - 数据库
tags:
  - mysql
abbrlink: 56288
date: 2022-02-20 19:54:20
cover : https://img.php.cn/upload/article/000/000/024/61505c2a73cf1419.jpg
---

# 事物

事物是什么，通俗来讲就是一次完整的逻辑操作。

是数据库操作的最小工作单元。



# ACID

**事物的四大特性**

## 原子性(**Atomicity**)

原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。比如在同一个事务中的SQL语句，要么全部执行成功，要么全部执行失败。



感觉与线程安全特性有点像，要么全部成功，要么全部失败。

**原子性是由undo log日志保证的，它记录了需要回滚的日志信息，也就是说我们的事务还没提交需要回滚，那么事务回滚就是根据undo log日志来撤销已经执行成功的SQL。**



## 一致性（※）



事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。

如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态；如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

一致性是ACID的目的，也就是说，只需要保证原子性、隔离性、持久性，自然也就保证了数据的一致性。

比如说，我们的ID在数据库中是唯一的，此时插入了一个唯一ID，数据库会给我们做一个检查，告诉咱们是否发生了主键冲突，如果主键冲突数据就无法插入。

另一部分是业务数据的一致性，这需要程序代码来保证。

比如说转账这个场景，假设我要转账100元出去，实际上数据库中只有90元，那这时候就不应该转账成功，这种情况通过数据库是无法保证的，只能由程序来保证。







## 隔离性（重要）

事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

数据库提供一定的隔离机制来保证不同事务的中间状态互不可见，保证每个事务不受其他事务的影响，每个事务独立进行。

**在MySQL中隔离性是通过MVCC多版本并发控制机制来保证的**







## 持久性

持久性是 指一个事务一旦被提交，**它对数据库中数据的改变就是永久性的**，接下来即使数据库发生故障也不应该对其有任何影响。



# 事务并发可能出现的问题

以下是三种**现象**。



## 脏读

比如两个事物A，B.

事物A读到了事物B还未提交的数据，这时候就产生了脏读现象。（脏读只在读未提交隔离级别才会出现）

举例：事务A   值为10 然后减去4 得到 6，事务B 此时读到值为6，然后再减去 1 得到5 ，好巧不巧，事务A回滚了，那事务B读到的6就为脏数据，没有意义。





## 不可重复读



比如两个事物A、B、C、D等等。

事物A**只能**读到其他已经提交事物（B、C、D等等）修改后的数据（或者读到的都是其他已经提交事务修改后的数据）。并且其他事务对数据修改之后，事物A能立即读到最新值，**从而事务A多次读取的数据不一致**。（（不可重复读在读未提交和读已提交隔离级别都可能会出现））。**这是一种现象**。



举例：在一个事务里面，第一次读到的是true,第二次读到的就是false(肯定是其他事务改了),第三次读到的又是true,重复读取同一个变量的结果不一样，我们在开发中一个事务重复读取的值尽量不要改变，这是事务并发产生的问题。

自己的偏激理解：你不能重复读，重复读的数据不一致。





## 幻读

直接上图

![img](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/PZF3QTAEO%5BKAYFAQEA42VW.png)



**总结**(这个总结很好)

![img](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/BSC60FES%7DRAMJ2J%5B_HH%7DQNY.png)

# 隔离级别

## 读未提交（READ UNCOMMITTED）

**第一档**

- **解释**：在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。
- **产生问题**：可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。



自己偏激理解：读到的是”最新数据“。

## 读已提交（READ COMMITTED）

**第二档**Oracle数据库默认隔离级别。

- **解释**：在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。读到的都是其他事务提交的数据。
- **产生问题**：读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。



自己偏激理解：读到的是事务已经提交的”最新数据“（其他事务提交之后才能读到）。

## 可重复读（REPEATABLE READ）

**第三档**，**mysql默认隔离级别**



- **解释**：在可重复读隔离级别下，事务A只能在事务B**修改**过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据,但是允许其他事务进行insert操作，所以产生了幻读。

  

- **产生问题**：**可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。**（**幻读问题innodb除外**）



可重复读解决了不可重复读现象，事务开启之后，只要你这个事务没有结束，不论你其他事务怎么样修改数据，事务A读到的还是它这个事务开启瞬时数据库的数据，所以其他事务怎样修改都没有用，读不到（也可以说读的是旧副本）。

可重复读隔离级别解决了不可重复读现象，但是解决不了幻读现象。事务A根据条件读取数据后，事务B进行了insert操作，事务A再次根据条件查询时，数据库是真实的增加了新的的数据，但是查的话查不到，还是原来的数据，这就产生了幻读现象。



可重复读隔离级别下，事务读的是历史数据，不是实时数据。

提问：为什么上了写锁（写操作），别的事务还可以读操作？

因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

## 可串行化（SERIALIZABLE）

**第四档，也是最高隔离级别。最安全，但是效率最低**

- 解释：：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
- 产生问题：各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）







![image-20220221205735126](../../images/mysql/image-20220221205735126.png)





# 锁分类(重点)



![image-20220924120303565](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/image-20220924120303565.png)





## 插入意向锁



**插入意向锁**，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。



**多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。**



插入意向锁与插入意向锁互不冲突，但是插入意向锁与间隙锁和next-key lock冲突



**提高并发插入效率**



1. `插入意向锁`是一种特殊的`间隙锁` —— `间隙锁`可以锁定**开区间**内的部分记录。
2. `插入意向锁`之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（`主键`、`唯一索引`）不冲突，那么事务之间就不会出现**冲突等待**。

需要强调的是，虽然`插入意向锁`中含有`意向锁`三个字，但是它并不属于`意向锁`而属于`间隙锁`，因为`意向锁`是**表锁**而`插入意向锁`是**行锁**。






### 解释

插入意向锁是一种特殊的间隙锁（简写成 II GAP）表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混了。

插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id = 30 和 id = 49 之间如果有两个事务要同时分别插入 id = 32 和 id = 33 是没问题的，虽然两个事务都会在 id = 30 和 id = 50 之间加上插入意向锁，但是不会冲突。

插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。



## 插入意向锁提高效率



InnoDB使用插入意向锁，可以提高插入并发，具体看例子。











## 插入意向锁冲突

![img](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/v2-7393ed4d69d62f34af463b5cf446b7f6_720w.jpg)









其中，第一行表示已有的锁，第一列表示要加的锁。插入意向锁较为特殊，所以我们先对插入意向锁做个总结，如下：

- **插入意向锁不影响其他事务加其他任何锁。也就是说，一个事务已经获取了插入意向锁，对其他事务是没有任何影响的；**
- **插入意向锁与间隙锁和 Next-key 锁冲突。也就是说，一个事务想要获取插入意向锁，如果有其他事务已经加了间隙锁或 Next-key 锁，则会阻塞。**

其他类型的锁的规则较为简单：

- 间隙锁不和其他锁（不包括插入意向锁）冲突；
- 记录锁和记录锁冲突，Next-key 锁和 Next-key 锁冲突，记录锁和 Next-key 锁冲突；









## Insert加锁流程(重点)



具体 Insert 语句的加锁流程如下：

- 首先对插入的间隙加插入意向锁（Insert Intension Locks）如果该间隙已被加上了间隙锁或 Next-Key 锁，则加锁失败进入等待；如果没有，则加锁成功，表示可以插入；
- 然后判断插入记录是否有唯一键，如果有，则进行唯一性约束检查如果不存在相同键值，则完成插入如果存在相同键值，则判断该键值是否加锁如果没有锁， 判断该记录是否被标记为删除如果标记为删除，说明事务已经提交，还没来得及 purge，这时加 S 锁等待；如果没有标记删除，则报 duplicate key 错误；如果有锁，说明该记录正在处理（新增、删除或更新），且事务还未提交，加 S 锁等待；
- 插入记录并对记录加 X 记录锁；







**插入意向锁只对于insert语句生效，当insert语句插入某个间隙(某个区间)的某个位置时候，他会先先对该插入的位置加上插入意向锁，如果插入所在区间有间隙锁或者next-key-lock的话，那么加插入意向锁失败，会阻塞事务，（插入意向锁与间隙锁和netx-key-lock互斥），但是如果有多个事务对某个区间的某个位置插入的时候加插入意向锁的时候，只要插入的位置点，行数据不一样，那么是可以多个数共存的。**



## inset加的是什么锁

**insert会对插入成功的行加上排它锁，这个排它锁是个记录锁，而非next-key锁（当然更不是gap锁了），不会阻止其他并发的事务往这条记录之前插入记录。在插入之前，会先在插入记录所在的间隙加上一个插入意向gap锁（简称I锁吧），并发的事务可以对同一个gap加I锁。**如果insert 的事务出现了duplicate-key error ，事务会对duplicate index record加共享锁。这个共享锁在并发的情况下是会产生死锁的，比如有两个并发的insert都对要对同一条记录加共享锁，而此时这条记录又被其他事务加上了排它锁，排它锁的事务提交或者回滚后，两个并发的insert操作是会发生死锁的。







# mysql锁机制

加锁是给索引加锁，不是给数据加锁

## 锁的分类

1.从性能上分为**乐观锁**和**悲观锁**



悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库本身提供的锁机制实现。简单来说，就是只要我正在使用数据，别人都无法获取这条数据。

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所有人都可以获取同一条数据，让用户决定如何去做。乐观锁可以通过**版本号**的方式实现，也就是在数据库表中添加一个版本号字段，用户拿到数据后和自己的版本号进行对比，如果不一致就跳过，一致则进行处理。相比于悲观锁而言，乐观锁的吞吐量更高。



2.从对数据库操作的类型分，分为**读锁**和**写锁**

- ​			读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响，但是不能进行写操作。
- ​			写锁（排它锁）：针对同一份数据，当前写操作没有完成前，其他写操作和读操作都会被阻断。
- 

3.根据加锁的范围，MySQL 里面的锁大致可以分成**全局锁**、**表级锁**和**行锁**三类



- ​	全局锁：

​             顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock              (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

​             **全局锁的典型使用场景是，做全库逻辑备份。**

- ​      表锁：
  ​          每次操作锁住整张表。它的特点是：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发性能差。
- ​      行锁：
  ​           每次操作锁住一行数据。它的特点是：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发性能高。

对于不同的引擎而言，**MyISAM**引擎的表只有表锁，不支持事务；而**InnoDB**的表既有表锁也有行锁，并且支持事务



有个更全的锁分类图

![image-20220304173353800](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/image-20220304173353800.png)





## 表锁



举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。





**直白点说：**

在会话A中如果给表加读锁，那么在这个会话A中只能读，不能写，其他会话也是只能读不能写。

在会话A中如果给表加写锁，那么在这个会话A中可以读写，其他会话读写这个表会被阻塞，只能等会话A释放表锁。



在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

## 行锁

> MySQL InnoDB支持三种行锁定方式：**InnoDB的默认加锁方式是next-key 锁。**：
>
> - l  行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。
> - l  间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。
> - l  Next-Key Lock ：行锁和间隙锁组合起来就叫Next-Key Lock。 

> 默认情况下，InnoDB工作在可重复读(Repeatable Read)隔离级别下，并且会以Next-Key Lock的方式对数据行进行加锁，这样可以有效防止幻读的发生。Next-Key Lock是行锁和间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。 read committed隔离级别下
>
> 行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。
>
> **Gap Lock在InnoDB的唯一作用就是防止其他事务的插入操作，以此防止幻读的发生。**
>
>  **Innodb自动使用间隙锁的条件：
> （1）必须在Repeatable Read级别下
> （2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）** 



锁定某一行可以用`lock in share mode`(共享锁) 和`for update`(排它锁) 来锁定



**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放**上。



### 行锁变表锁

MySQL 的 InnoDB 存储引擎支持支持行级锁，得益于这些一性，数据库支持高并发。但是**innodb的行锁是通过给索引项加锁实现的**，在一些情况下，InnoDB的行锁其实很容易升级为表锁的，这样并发性将大打折扣：

1. 将事务隔离级别设置为**串行化(serializable)**时，InnoDB会使用表锁。
2. 有时候， SQL 语句中未使用到索引会导致行锁升级为表锁。比如使用`varchar`类型的索引在查询时没有加单引号。
3. 对于普通索引，如果设置不当会导致操作时行锁升级为表锁。比如给一个重复率非常高的字段加了索引，并且通过这个字段进行操作时，行锁引很可能会变为表锁。



## 行锁的三种实现

1.记录锁

2.间隙锁

3.next_key_lock

## 死锁

死锁发生在表锁中

在InnoDB表中死锁也是有可能发生的。比如第一个事务获得了id=1对应行的锁，第二个事务获得了id=2对应行的锁，这时第一个事务又要申请id=2对应行的锁，第二个事务又要深取id=1对应的行锁，这样死锁就发生了：

### 怎么解决死锁

**mysql有死锁检测机制，先释放掉发生死锁事务中增删改Sql数最小的那个事务。**



**我们也可以根据死锁日志来改变sql加锁的顺序，或者建立何时的索引来改变加锁过程**







## 行锁与表锁能否共存？

这个问题困扰了很久，网上答案也是模糊不清。

首先回答是可以的，**但是只有s行锁与s表级锁能共存。**



先介绍意向锁是个什么的

首先事务在申请行级锁之前会先申请相应的意向锁，此时其他事务想申请表锁的时候就先判断有没有意向锁，不用逐行校验有没有数据行被锁住，提高了效率。而且**意向锁是表锁**







**先看看各种锁互斥与兼容关系**



1.**意向锁不会与行级的共享 / 排他锁互斥**，

**2.**

![img](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/v2-12e0ee9c0ab14601f7d3ca56d5cdbde7_720w.jpg)

3.

![img](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/v2-e02840d766802dc67c4a90215a24b4a8_720w.jpg)



**这样就可以总结出，IS（意向共享锁）与S表级锁是兼容的，那么事务在申请s表级锁的时候，就算其他事务申请了s行锁,也是可以申请到s表级锁的，这就是这个问题的答案。**











## 间隙锁与间隙锁是兼容的





同个间隙之间的间隙锁可以被多个事务同时拿到





**间隙锁的意义只在于阻止区间被插入**，因此是可以共存的。**一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁**，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。







这里的共同间隙包括两种场景：

- **其一是两个间隙锁的间隙区间完全一样；**
- **其二是一个间隙锁包含的间隙区间是另一个间隙锁包含间隙区间的子集。**



## 分类总结

**行锁锁的是索引**

行锁、表锁是对于锁粒度而言的，是一对最广泛的概念。表锁的实现很好想，就是需要一个标志来记录当前有没有事务已经来操做表了。而行锁的实现是锁的索引，根据锁索引的范围又可以分为记录锁、间隙锁、临键锁。

比如说我们修改一个数据库已经有的记录，那直接锁相应索引就行（记录锁）；再比如我们给一张有两条数据的表（id=1，id=10）进行范围查询并加锁 where id>2 and id < 5 for update，此时命中了一个不存在数据的区间(2,5)，这时该锁哪？是锁两个索引之间的整个区间（1,10），这就是间隙锁。临键锁=记录锁+间隙锁。



注意，间隙锁主要是阻塞插入insert，而没有阻塞select。相同的间隙锁之间不冲突。

InnoDB 行级锁是通过给索引上的索引项加锁来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁;否则，InnoDB使用表锁 在不通过索引(主 键)条件查询的时候，InnoDB是表锁而不是行锁



# Mysql加锁规则（※）

[mysql45讲加锁规则]: https://www.cnblogs.com/a-phper/p/10313940.html





**行级锁默认加 next-key lock，查询过程中访问到的索引项都会加锁，而根据不同的索引也有不同的加锁规则：**

## 唯一索引等值查询

- 唯一索引等值查询：当索引项存在时，next-key lock 退化为 record lock；当索引项不存在时，默认 next-key lock，访问到不满足条件的第一个值后next-key lock退化成gap lock

## 唯一索引范围查询

- 唯一索引范围查询：默认 next-key lock，(特殊’<=’ 范围查询直到访问不满足条件的第一个值为止)



## 非唯一索引等值查询

- 非唯一索引等值查询：默认next-key lock ，索引项存在/不存在都是访问到不满足条件的第一个值后next-key lock退化成gap lock

**解释：**当隔离级别不小于RR时候，如果匹配模式为精确匹配，则会为扫描区间后面的下一条记录加gap锁





## 非唯一索引范围查询

- 非唯一索引范围查询：默认 next-key lock，向右访问到不满足条件的第一个值为止(这个不满足条件的值也会加上next_key_lock锁)

**解释：**当隔离级别不小于RR时，如果匹配模式不是精确匹配，并且没有找到匹配的记录，则会为该扫描区间后面的下一条记录加next-key锁。





## 主键索引范围锁

当隔离级别不小于RR时，如果使用的是聚簇索引，并且扫描的扫描区间是左闭区间，而且定位到的第一条聚簇索记录的number值正好与扫描区间中最小的值相同，那么会为该聚簇索引记录加上记录锁，往后找的时候还是加的是next_key_lock。













# MVCC

## MVCC解决了什么

MVCC是多版本并发控制



MVCC解决了无锁情况下的读写冲突。这个读是快照读





## 简介

**MVCC**（Multi-Version Concurrency Control）：多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

**MVCC** 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理**读-(快照读)写冲突**，做到即使有读写冲突时，也能做到**不加锁**，非阻塞并发读。

**注意**：**这个读是快照读，不是当前读**



**快照读**与**当前读**



> **当前读**
>
> ![image-20220305131004195](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/image-20220305131004195.png)
>
> **快照读**
>
> 像不加锁的select操作就是快照读，即不加锁的非阻塞读。快照读的前提是隔离级别不是串行化级别，串行化级别下的快照读会退化成当前读。之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是就是基于多版本并发控制，即MVCC。可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即**快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本**。





## MVCC实现原理

MVCC实现原理有重要的三部分： 1.两个隐藏字段 2. 记录链 3. readview(读视图)



### 两个隐藏字段

数据库的每行记录除了我们自定义的字段外，还有一些隐藏字段，这些隐藏字段在MVCC机制里面发挥了重要作用。

- **DB_TRX_ID**：最近修改(`修改/插入`)事务ID，用来记录最后一次修改该记录的事务ID。Mysql会给每个事务分配一个id，这个id是不断增长的，每次加1，所以**事务越新id越大**。
- **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本。
- **DB_ROW_ID**：隐含的自增ID，即隐藏主键。如果数据表没有创建主键，InnoDB会自动以该列产生一个聚簇索引。
- **flag字段**：删除标记字段，记录被更新或删除并不代表真的删除，而是该标记字段变了。

如果我们自己设置了主键，那么就不会有**DB_ROW_ID**字段出现。

### 记录链

**记录链主要是靠undo log日志记录的**

undolog日志分以下两个

- insert undo log
  代表事务在`insert`新记录时产生的`undo log`，只在事务回滚时需要，并且在事务提交后可以被立即丢弃。
- update undo log
  事务在进行`update`或`delete`时产生的`undo log`， 不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除。只有在快速读或事务回滚不涉及该日志时，对应的日志才会被`purge`线程统一清除。（MVCC主要靠的就是这个日志）

日志操作

![image-20220305131616299](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/image-20220305131616299.png)



不同事物或者相同事物对同一记录的修改，会导致改记录的undo log成为一条记录链表，链首是最新的旧记录，链尾是最早的旧记录。



**注意：只要一个事务开启，对数据进行了修改，数据记录链中都插入该事务id修改的记录，无论有没有提交。只是根据事务执行的结果会进行不同的操作，如果事务`commit`就会保留该记录，如果事务`rollback`就会删除该记录。**





### readview

Read View是非常重要的一个概念，需要读者理解。一个事务进行**快照读**操作时，会生产一个**读视图**，即ReadView。在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID。

活跃的事物id就是在快照读那一刻，还没有commit的事务。

**readview是用来做可见性判断的，它用来判断当前事务在进行查操作时，能看见记录链里的哪一个版本的数据。**





**怎样判断可见性**

### 主要流程

`Read View`遵循一个可见性算法：对某行(几行)数据进行**快照读**时 (产生了**Read View**) ，会从这一行(几行)在记录链中的最新数据中，取出隐藏字段`DB_TRX_ID`的ID值，与`Read View`中维护的值进行某些比较，如果不符合可见性，那就通过`DB_ROLL_PTR`回滚指针去取出记录链中下一条数据的`DB_TRX_ID`继续比较。**即从头到尾遍历记录链的`DB_TRX_ID`与当前Read View中的值进行比较，直到找到满足特定条件的`DB_TRX_ID`，那么对应的这条数据就是当前事务可见的最新旧记录**。

**以下是具体流程**



![image-20220305142210087](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/image-20220305142210087.png)

下面解释以下readview里面维护的字段

| live_txn_list  | 表示在生成readview时，当前系统活跃的读写事务的事务id列表     |
| -------------- | ------------------------------------------------------------ |
| up_limit_id    | 表示生成readview时，当前系统中活跃的事务id的最小值，也就是最小的活跃事务id |
| low_limit_id   | 生成readview时，活跃事务id的最大值加1，也就是应该分配给下一个事务的id值 |
| creator_trx_id | 表示生成该readview的事务的事务id                             |







为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。理解起来就是创建RV时，将当前活跃事务ID记录下来，后续即使他们提交对于本事务也是不可见的。

> **3、up_limit_id <=**数据事务ID<**low_limit_id 则与活跃事务集合**trx_ids**里匹配**
>
> 如果数据的事务ID大于最小的活跃事务ID,同时又小于等于系统最大的事务ID，这种情况就说明这个数据有可能是在当前事务开始的时候还没有提交的。
>
> 所以这时候我们需要把数据的事务ID与当前read view 中的活跃事务集合trx_ids 匹配:
>
> **情况1:** 如果事务ID不存在于trx_ids 集合（则说明read view产生的时候事务已经commit了），这种情况数据则可以显示。
>
> **情况2：** 如果事务ID存在trx_ids则说明read view产生的时候数据还没有提交，但是如果数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。
>
> **情况3：** 如果事务ID既存在trx_ids而且又不等于creator_trx_id那就说明read view产生的时候数据还没有提交，又不是自己生成的，所以这种情况下此数据不能显示。



![image-20220923230231059](../../images/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E6%9C%BA%E5%88%B6/image-20220923230231059.png)



**活跃的事务Id也就是没有commit的事务Id**



具体流程是怎样的，加入我们开启一事务后，要查某一行数据，那么我们就从这行对应的记录链的最新数据取出DB_TRX_ID（也就是这条记录操作的事务id），接下来就要将这个值与readview中维护的值进行比较：

1. 当DB_TRX_ID < up_limit_id,表示这条记录的操作事务在本**readview**开启前就已经提交，对本事务是可见的。否则进入下一步比对
2. 当DB_TRX_ID  ==  creator_trx_id，表明这条数据是本事务自己操作的，对自己当然可见，否则进入下一步比对。
3. 当DB_TRX_ID  > = low_limit_id,表明这条数据的操作事务是本事务在开启当前readview产生后才开始的。对于本事务不可见，否则进入下一步比对。
4. 判断DB_TRX_ID  是否在活跃事务数组live_txn_list里面，如果不在，就说明，这个事务在readview生成前就commit了，那么其修改的数据对应本事务是可见的，如果在，说明在当前readview生成的时候，这个事务还没有commit,那么他修改的数据是不可见的。否则进入下一步。
5. 通过DB_ROLL_PTR回滚指针取出后面一条数据，如果指针为null,说明没有满足条件的数据，返回null,否则会到第一步。



**总结**：通过readview与记录对比来说，对应本事务能看见的数据事务是当前事务开启前的事务操作的数据，和当前事务开启前但没有生成readview的时候，commit的事务操作的数据，已经本事务操作的数据。





> 那么在可重复读隔离级别下就是通过MVCC机制来达到，多次快照读读取的数据不变，保证了可重复读。
>
> 
>
> 读已提交与可重复读这两个事务隔离级的不同在于**InnoDB的快照读时Read View生成时机不同**，这也是为什么读已提交事务隔离级别会存在**不可重复读**：
>
> - 在可重复读隔离级别下的某个事务对某条记录的第一次快照读会创建一个快照及Read View，并且此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。
> - 而在读已提交级隔离级别下的，事务中每次快照读都会新生成一个新的Read View，这就是我们在读已提交隔离级别下的事务中可以看到别的事务提交的更新的原因。



# 幻读解决了吗

这个问题来来回回改了好多遍。



**重要：在RR隔离级别下。MySQL没有完全解决幻读问题，MVCC也没有彻底解决幻读。**（看下面举例）



而且MVCC只能解决**部分幻读，幻读解决不彻底**，不能完全解决同时有快照读select和当前读下select下产生的幻读问题（为什么是快照读，毕竟MVCC只在快照读下产生效果）

举例：如果第一次快照select,第二次当前select,第一次快照读只能读生成readView之前提交的事务数据和当前事务操作的数据（具体能读到什么数据看上面那个图）。而第二次当前读可能中间又有数据插入，而当前读又是读的最新数据，所有可能出现幻读。







**情景分析**

​	前提：在一个事务里面。

1. 两次都是快照读，不会产生幻读（如果同一个事务两次都是快照读，或者一个事务里面都是快照读是不会产生幻读问题的）

2. 两次都是当前读，不会产生幻读（next_key_lock彻底解决了幻读）

   



当前读采用Next-key Lock(间隙锁)（前开后闭） 来解决幻读问题







## 举例

**小孩子书上424页举例。**

下面举例，为什么MVCC不能彻底解决幻读。



dgw表中现在有三个字段，number name conutry

表中数据为null在一开始。

| 事务T1                                                       | 事务T2                                   |
| ------------------------------------------------------------ | ---------------------------------------- |
| begin;                                                       | begin;                                   |
| select * from dgw where number = 30;                         |                                          |
|                                                              | insert into dgw values('30','dgw','魏'); |
|                                                              | commit;                                  |
| update dgw set counrty = '蜀' where number = 30;             |                                          |
| select *from dgw where number = 30;(第二次快照查已经出现了幻读) |                                          |



这是书上的作者为了举例专门挑了一个例子来解释MVCC不能彻底解决幻读，**但是在同一个事务里面，如果select都是快照读是可以解决幻读的**。



默认都是在RR级别下，事务T1第一次执行普通select语句生成了一个ReadView,之后T2向dgw表中新插入了一条记录并提交。ReadView并不能阻止T1执行了UPDATE或者DELETE语句来改动这个新插入的记录（由于T2已经提交，所以改动该记录不会造成堵塞），但是这样一来，这条新纪录的trx_id隐藏列的值就变成了T1的事务id。之后T1在使用普通的SELECT语句去查询这条记录就可以看到这条记录了，也可以把这条记录返回给客户端。

所以我们也可以认为MVCC并不能完全禁止幻读。



**PS: 当你执行这几个操作的时候默认会执行当前读，也就是会读取最新的记录**



# 数据库设计三大范式

https://www.cnblogs.com/shangping/p/11088503.html









# mysql乐观锁与悲观锁



https://blog.csdn.net/m0_58559010/article/details/119418043





https://zhuanlan.zhihu.com/p/100703597

**mysql查询语句通常会有where 1 = 1,很方便的解决我们条件为空的问题，不影响查询效率，也会走索引。**

```mysql
select * from t_book where 1=1 and title = "且在人间"
```









 









