---
title: mysql深入索引
categories:
  - 数据库
tags:
  - mysql
abbrlink: 56288
date: 2022-03-2 19:54:20
cover : https://img.php.cn/upload/article/000/000/024/61505c2a73cf1419.jpg
---







# 索引的出现

## 索引是什么

一句话概括：**索引是帮助MySQL高效获取数据的排好序的数据结构**

**索引的出现**其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。







# 索引的常见数据结构

## 树

### 二叉搜索树

![image-20220301173750882](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301173750882.png)

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -> UserC -> UserF -> User2 这个路径得到。这个时间复杂度是 O(log(N))。



当然为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。



树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。



如果存储数据过多的话，二叉搜索树的树很高的，树高有好几十，那么磁盘io次数相应的就很多（把数据从磁盘加载到内存的次数增多）。



那我们为了让一个查询尽量的少读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树，N 叉”树中的“N”取决于数据块的大小。。



以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。



B树与B+树就是这样一个结构，**多路平衡查找树**。



### B树

![image-20220301174445916](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301174445916.png)



B树的一个大结点存储了许多小结点，每个小结点存储了索引值和对应表中行的完整数据。另外，每个大结点还存放了许多指向下一个子结点的指针。大结点通常都是存储在一个页中，大小通常是16kb。如果每个大结点的大小一定，小结点的数据越大，那么大结点存储的小结点就越少。



都知道存储引擎现在基本都采用的是B+树，那么为什么放弃了B树

**B树性能差的原因**：

- B树的树高越高，磁盘io次数就多了，性能就差了，相比于B+树，让他树高的原因为他的所有结点存放了索引值和对应的行数据（也就是图中的data），可能行数据（data）的大小远远超过了索引的大小，导致每个非叶子结点能放的索引值就少了（每个结点的大小一定），所以B树就得不断增加树高来存放所有数据，这也是他比B+树性能差的原因之一。

  

- 另外用B树来做范围查询的话，需要使用中序遍历，这会涉及多个结点的磁盘io问题，从而导致整体速度下降。

- b树可能查到某个非叶子结点就返回了，b+树要一直查询到叶子结点才返回



### B+树

B+树是大多数存储引擎创建索引默认的数据结构（innodb,myisam等等）。

![image-20220301174500486](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301174500486.png)



相比于B树，B+树的优化就明显了。

**1.B+树的非叶子结点只存放索引，不存放对应的行真实数据。**



非叶子节点中的索引只用来搜索，而不存储对应的data。这样就消除了表中每行数据大小对节点存储量的影响，使得每个大节点中可以存放更多的小节点（更多的索引）。



**2.叶子结点包含所有索引字段和行真实数据。**



由于非叶子节点中只有索引值，没有data，因此在叶子节点中需要包含所有的索引字段和对应的data。与B树不同，B树中所有索引元素不重复，而B+树中有的索引有两份，一份是非叶子节点的冗余索引而另一份包含了索引和data。



**3.叶子节点用指针连接，提高区间访问的性能**



B+树的所有叶子结点都是拿指针相连的，并且是有序排列的，这一点是B树所不及的。

拿下图举例，我们需要区间搜索大于等于20的所有元素，如果没有该指针，拿到20和30后需要重新从根节点搜索；如果有了指针，拿到20和30后可以利用指针直接从下一个相邻的叶子节点开始查找。



![image-20220301192218044](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301192218044.png)



mysqlB+树一页大小是16kb,假设索引字段类型是Bigint，8byte，每两个元素之间存的是下一个节点的地址，mysql分配的是6bit，也就是说一个索引后面配对一个节点地址，成对出现，可以算一下16K的节点可以存多少对也就是多少个索引，8b+6b=14b，16K /14b=1170个索引，叶子节点有索引有data元素，假设占1K，那一个节点就放16K/1K=16个元素，假设树高是3，所有节点都放满，能放多少数据？可以算一下，1170***1170 ***16=21902400，2千多万，mysql设置16K的大小，数据就可以存2千多万就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。



#### B+树时间复杂度

二叉树树是log2 n

b+树是m叉，所以是logm n;

又因为每一层是m / 2;







### B树与B加树总结

**B+树相比于B树的改进**

当树的结点数目过多时，为了减少查询时间而引入了多路的平衡树，即B树；

B+树是对B数的一种优化，改进的地方有两点， 

- 一是更改了内部结点的数据存储方式， 不让其直接存储data, 这样在同样大小的存储空间下其对应的索引key会更多，查询起来速度会更快。（[为什么这样下面有解释]()）
- 二是在叶子结点之间增加了链接， 将原本多个孤立的单独区间给串联起来了，可以利用磁盘预读一页后面的额外连续几页数据，这样将减少磁盘读取的次数。 



**B树与B+树的区别**

1. **B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。**

   

2. **B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。**

   

3. **B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确**

*这个很好理解，由于B-树节点内部每个 key 都带着 data 域，而B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着B+树单次磁盘 IO 的信息量大于B-树，从这点来看B+树相对B-树磁盘 IO 次数少。*

**接上面的为什么**（在B树改进那块的问题）

B树的树高越高，磁盘io次数就多了，性能就差了，相比于B+树，让他树高的原因为他的结点存放了索引值和对应的行数据（也就是图中的data），可能行数据（data）的大小远远超过了索引的大小，导致每个非叶子结点能放的索引值就少了（每个结点的大小一定），所以B树就得不断增加树高来存放所有数据，而B+树因为非叶子结点只存放索引值，所以一个非叶子结点存放的索引值是远多于B树，进而导致B+树的树高普遍比B树树高低（B树一般树高是3或者4层）。



## Hash

除了B树和B+树，还有一种底层采用哈希表的索引数据结构。

### 哈希表简单介绍

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

如果表索引底层采用哈希表结构，我们俗称这个索引为Hash索引。



![image-20220301171418745](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301171418745.png)

简单来说，**哈希索引方式就是采用一定的哈希算法**，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置。并且，因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引的速度非常快。但是哈希索引也有它明显的限制:

​	**哈希表这种结构适用于只有等值查询的场景，适用不了范围查找等等。**



















# 常见的索引类型

## 聚簇索引

![image-20220301201002613](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301201002613.png)



根据叶子节点的内容，索引类型分为主键索引和非主键索引。

- 主键索引的叶子节点存的是整行数据，找到索引也就找到了数据。在 InnoDB 里，主键索引也被称为**聚簇索引**（clustered index）。

- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为**二级索引**（secondary index）。

  

**基于主键索引和普通索引的查询有什么区别？**

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为**回表**。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。



**注意点**：

**聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。**

## 联合索引

联合索引就是多个字段构建索引。

ysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。





## 覆盖索引

![image-20220301203733165](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301203733165.png)

本质来说，覆盖索引并不是一种索引，而是一种查询方式，我们要查找的结果集在索引树里面。



如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。

或者这样说：从辅助索引中就可以得到查询的记录，而不用回表来查询聚簇索引中的记录。



**举例**

如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，可以根据身份证号和名字联合索引。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。

**好处**

1. 索引条目通常远小于数据行大小，只需要读取索引，则mysql会极大地减少数据访问量。
2. 因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很
3. 减少回表操作





**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

网上说覆盖索引就是一种特殊的联合索引，这个说法好像还可以。





## 最左前缀原则

> 如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？
>
> **B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**
>
> 如果设置了包含多列的联合索引，那么，只要满足最左前缀原则（查询时从索引的最左前列开始且不跳过索引中的列），就可以利用索引来加速检索。
>
> 
>
> 假如根据name(姓名)  age(年龄)   addr(地址) 三个字段来建立联合索引
>
> ```mysql
> # 搜索时联合索引name字段生效
> select * from stu where name = 'dgw'; 
> # 搜索时联合索引name,age字段生效
> select * from stu where name = 'dgw' and age = 20;
> # 搜索时联合索引name,age,addr字段生效
> select * from stu where name = 'dgw' and age = 20 and addr = 'xian';
> # Mysql内部会自动优化，联合索引name,age,addr字段生效
> select * from stu where age = 21 and name = 'dgw' and addr = 'xian'
> # 搜索时联合索引name字段生效
> select * from stu where name = 'dgw' and addr = 'xian';
> # 搜索时联合索引不生效
> select * from stu where age = 20 and addr = 'xian';
> ```
>
> 
>
> 大家可能注意到了第四条，我们并没有按照从左到右的顺序来写，但是搜索时联合索引的所有字段都生效了。这是因为Mysql内部会进行优化，根据我们设置联合索引的顺序来对搜索条件中的字段顺序进行调整，因此只要不跳过字段，无论顺序怎样都能生效，但还是推荐大家按顺序写。





# 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。

除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。

当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。



所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。

# 索引失效的场景

1. or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效; 
2. 复合索引未用左列字段，即不是使用第一列索引，索引失效;
3.  like以%开头，当like前缀没有%，后缀有%时，索引有效; 
4. 需要类型转换; 
5. where中索引列有运算，或者索引列使用了函数;; 
6. where中在索引字段上使用not，<>，!=。（不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。key<>0 改为 key>0 or key<0。）不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。优化方法：key<>0 改为 key>0 or key<0。）
7.  如果mysql觉得全表扫描更快时（数据少）;
8. 在索引列上使用 IS NULL 或 IS NOT NULL操作。

# Innodb与MyISAM

这是常用的两种存储引擎，存储引擎是基于表的，在创建表的时候就应该指定存储引擎。

他们有什么区别呢？

在存储表的文件上面。

![image-20220301135324912](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220301135324912.png)



Innodb通常有两个文件，如上图的.frm和.ibd文件

- .frm存储表结构信息的文件
- .ibd文件存放索引和表真实数据

MyISAM通常有3个文件，如上图的.frm文件和.MYD和.MYI文件。

- .frm存储表结构信息的文件

- .MYD存放真实数据

- .MYI存放索引

  

MyISAM无论是主键还是非非主键构建的索引都是这样的，索引与表数据存在于两个不同的文件，所以，MyISAM构建的都是**非聚簇索引**。





# 索引下推



概括，把以前需要在server层负责的事情交由引擎层负责





**举例**

使用一张用户表`tuser`，表里创建联合索引（name, age）。

![用户表](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/1b49ff7a5bff433688d7640d1ca64fb4tplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp)



如果现在有一个需求：检索出表中`名字第一个字是张，而且年龄是10岁的所有用户`。那么，SQL语句是这么写的：



```mysql
select * from tuser where name like '张%' and age=10;
```



**假如你了解索引最左匹配原则，那么就知道这个语句在搜索索引树的时候，只能用 `张`，找到的第一个满足条件的记录id为1。**

![B+树联合索引](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/a2db6afbc11546fbb4205b2faa64400ftplv-k3u1fbpfcp-zoom-in-crop-mark1304000.awebp)

接下来

## 没有使用索引下推



存储引擎根据通过联合索引找到`name like '张%'` 的主键id（1、4），逐一进行回表扫描，去聚簇索引找到完整的行记录，server层再对数据根据`age=10进行筛选`。





## 使用索引下推



存储引擎根据（name，age）联合索引，找到`name like '张%'`，由于联合索引中包含`age`列，所以存储引擎直接再联合索引里按照`age=10`过滤。按照过滤后的数据再一一进行回表扫描。





## 具体步骤



**我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：**

- 存储引擎读取索引记录；
- 根据索引中的主键值，定位并读取完整的行记录；
- 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件。

**使用ICP的情况下，查询过程：**

- 存储引擎读取索引记录（不是完整的行记录）；
- 判断`WHERE`条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
- 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
- 存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分。





## 总结

**索引条件下推`ICP`就是尽可量利用二级索引筛除不符合`where`条件的记录，如此一来减少需要回表继续判断的次数**







# 小林



这篇文章索引写的非常好

https://mp.weixin.qq.com/s/LTX67XxkWcAeYUyLh_5b4g



[小林]: https://mp.weixin.qq.com/s/LTX67XxkWcAeYUyLh_5b4g





为什么选择B+树





## **B+Tree vs B Tree**

B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。





## **B+Tree vs 二叉树**

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。





## **B+Tree vs Hash**

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。

但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。











# 一张表存放数据量

前文B+树那块也提到了



- 假设索引字段类型是Bigint，8bit，每两个元素之间存的是下一个节点的地址，mysql分配的是6bit，也就是说一个索引后面配对一个节点地址，成对出现，可以算一下16K的节点可以存多少对也就是多少个索引，8b+6b=14b，16K /14b=1170个索引，叶子节点有索引有data元素，假设占1K，那一个节点就放16K/1K=16个元素，假设树高是3，所有节点都放满，能放多少数据？可以算一下，1170*1170*16=21902400，2千多万，mysql设置16K的大小，数据就可以存2千多万就已经足够了吧，既能保证一次磁盘IO不要Load太多的数据 又能保证一次load的性能，即便表的数据在几千万的数量也能保证树的高度在一个可控的范围。

https://mp.weixin.qq.com/s/bLcvyPts1VbY5VyCluLYyw









# abc联合索引



![image-20220922231249409](../../images/mysql%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/image-20220922231249409.png)



